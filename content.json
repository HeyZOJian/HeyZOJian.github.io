{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com"},"pages":[{"title":"about","date":"2017-01-11T02:12:04.000Z","updated":"2017-01-11T02:12:04.000Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"archive","date":"2017-01-11T01:56:23.000Z","updated":"2017-01-11T01:56:23.000Z","comments":true,"path":"archive/index.html","permalink":"http://yoursite.com/archive/index.html","excerpt":"","text":""},{"title":"gallery","date":"2017-01-23T12:30:26.000Z","updated":"2017-01-23T12:30:26.000Z","comments":true,"path":"gallery/index.html","permalink":"http://yoursite.com/gallery/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-01-23T13:27:22.000Z","updated":"2017-01-23T13:27:22.000Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Django REST framework 教程2：请求和响应","slug":"Django-REST-framework-教程2：请求和响应","date":"2018-02-08T07:53:11.000Z","updated":"2018-02-08T09:26:18.989Z","comments":true,"path":"2018/02/08/Django-REST-framework-教程2：请求和响应/","link":"","permalink":"http://yoursite.com/2018/02/08/Django-REST-framework-教程2：请求和响应/","excerpt":"这一篇我们开始讲解RESTframework框架的核心内容。让我们介绍一些基本的构建模块。","text":"这一篇我们开始讲解RESTframework框架的核心内容。让我们介绍一些基本的构建模块。 Request对象REST framework引入了Request对象，它继承自常规的HttpRequest，并提供更加灵活的请求解析。Request对象的核心功能是request.data参数，类似于request.POST。 12request.POST # 只能处理表单数据. 只能处理‘POST’请求request.data # 处理任何数据. 处理‘POST’,'PUT',‘PATCH’. Response对象REST framework也引入了Response对象，使用内容协商来决定返回给客户端的数据类型。 1return Response(data) # 返回客户端请求的数据类型 状态码在视图中使用纯数字的HTTP状态码可读性差，并且不容易发现错误。REST framework为每个状态码提供了明确的标识符，例如status模块中的HTTP_400_BAD_REQUEST。 装饰API视图REST framework提供了两个可用于编写视图API的封装： @api_view装饰视图函数 APIView类可用作视图的基类 这些封装提供了一些额外的功能，例如确保了你的视图接受到Request实例，执行内容协商，并且把内容添加到Response对象中。 也会适当得返回405 Method Not Allowed响应，以及处理request.data格式不正确的ParseError异常。 把他们整合在一起让我们继续使用这些新组件写一些视图函数。 在views.py中我们不再需要JSONResponse类,所以删了它。完成后我们可以对我们的视图函数进行轻微的重构了。 1234567891011121314151617181920212223from rest_framework import statusfrom rest_framework.decorators import api_viewfrom rest_framework.response import Responsefrom snippets.models import Snippetfrom snippets.serializers import SnippetSerializer@api_view(['GET', 'POST'])def snippet_list(request): \"\"\" List all code snippets, or create a new snippet. \"\"\" if request.method == 'GET': snippets = Snippet.objects.all() serializer = SnippetSerializer(snippets, many=True) return Response(serializer.data) elif request.method == 'POST': serializer = SnippetSerializer(data=request.data) if serializer.is_valid(): serializer.save() return Response(serializer.data, status=status.HTTP_201_CREATED) return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST) 我们改进了之前的例子。变得更加简洁，代码风格也跟Forms API很像，同时使用了命名的状态码这使得响应内容更加明确。 单个页面的视图函数。 123456789101112131415161718192021222324@api_view(['GET', 'PUT', 'DELETE'])def snippet_detail(request, pk): \"\"\" Retrieve, update or delete a code snippet. \"\"\" try: snippet = Snippet.objects.get(pk=pk) except Snippet.DoesNotExist: return Response(status=status.HTTP_404_NOT_FOUND) if request.method == 'GET': serializer = SnippetSerializer(snippet) return Response(serializer.data) elif request.method == 'PUT': serializer = SnippetSerializer(snippet, data=request.data) if serializer.is_valid(): serializer.save() return Response(serializer.data) return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST) elif request.method == 'DELETE': snippet.delete() return Response(status=status.HTTP_204_NO_CONTENT) 应该感觉非常熟悉-这个普通的Django视图没什么不同。 注意到，我们没有明确请求或响应的数据类型。request.data可以处理传进来的json请求，也可以处理其他数据格式。同样，我们返回包含数据的响应时，REST framework会将数据渲染成恰当的数据格式。 给URLs添加可选的格式后缀利用上面的特性，我们的响应可以返回多种数据类型，让我们为API端点添加格式后缀的支持。意味着我们的API可以出来这种URLs http://example.com/api/items/4.json. 给所有的视图函数添加format关键字参数，就像 1def snippet_list(request, format=None): 和 1def snippet_detail(request, pk, format=None): 现在更新一下snippets/urls.py文件，将现有的URLs添加到一组format_suffix_patterns中。 12345678910from django.urls import pathfrom snippets import viewsfrom rest_framework.urlpatterns import format_suffix_patternsurlpatterns = [ path('snippets/', views.snippet_list), path('snippets/&lt;int:pk&gt;/', views.snippet_detail),]urlpatterns = format_suffix_patterns(urlpatterns) 它提供了一种简单的引用方式，因此我们不需要再添加额外的url模式。 看起来怎么样？继续在命令行中测试我们的API。一切好像没什么变化，除了我们发生无效的请求时多了一些很好的错误处理。 我们可以像之前一样获得所有代码片段。 12345678910111213141516171819202122http http://127.0.0.1:8000/snippets/HTTP/1.1 200 OK...[ &#123; \"id\": 1, \"title\": \"\", \"code\": \"foo = \\\"bar\\\"\\n\", \"linenos\": false, \"language\": \"python\", \"style\": \"friendly\" &#125;, &#123; \"id\": 2, \"title\": \"\", \"code\": \"print \\\"hello, world\\\"\\n\", \"linenos\": false, \"language\": \"python\", \"style\": \"friendly\" &#125;] 使用Accept头部字段，我们可以控制响应的格式： 12http http://127.0.0.1:8000/snippets/ Accept:application/json # 请求JSON数据http http://127.0.0.1:8000/snippets/ Accept:text/html # 请求HTML数据 或者添加格式后缀： 12http http://127.0.0.1:8000/snippets.json # JSON 后缀http http://127.0.0.1:8000/snippets.api # Browsable API suffix 同样，也可以使用Content-Type头部字段设置我们所发送的数据的数据格式。 1234567891011121314151617181920212223# POST 表单数据http --form POST http://127.0.0.1:8000/snippets/ code=\"print 123\"&#123; \"id\": 3, \"title\": \"\", \"code\": \"print 123\", \"linenos\": false, \"language\": \"python\", \"style\": \"friendly\"&#125;# POST JSON数据http --json POST http://127.0.0.1:8000/snippets/ code=\"print 456\"&#123; \"id\": 4, \"title\": \"\", \"code\": \"print 456\", \"linenos\": false, \"language\": \"python\", \"style\": \"friendly\"&#125; 如果你在上面的http命令前添加--debug，你还能在请求头部看到请求类型。 现在打开浏览器，访问 http://127.0.0.1:8000/snippets/. BrowsabilityAPI的响应类型取决于客户端的请求，但是默认情况下，当浏览器请求一个资源时会返回一个HTML格式的响应。 拥有一个可浏览的API是一个巨大的可用性胜利，并且使开发和使用API更容易。它也大大降低了想要检查和使用您的API的其他开发人员的障碍 想要了解更多可查阅browsable api 下一步是什么？在教程3，我们将会使用基于类的视图，并且学习如何通过视图减少大量的代码。","categories":[],"tags":[{"name":"Django","slug":"Django","permalink":"http://yoursite.com/tags/Django/"},{"name":"Django REST framework","slug":"Django-REST-framework","permalink":"http://yoursite.com/tags/Django-REST-framework/"},{"name":"翻译","slug":"翻译","permalink":"http://yoursite.com/tags/翻译/"}]},{"title":"Django REST framework教程1：序列化","slug":"Django-RESTful-framework教程1：序列化","date":"2018-02-07T14:10:46.000Z","updated":"2018-02-08T07:52:48.432Z","comments":true,"path":"2018/02/07/Django-RESTful-framework教程1：序列化/","link":"","permalink":"http://yoursite.com/2018/02/07/Django-RESTful-framework教程1：序列化/","excerpt":"介绍这个教程将创建一套简单的代码高亮的pastebin的Web API。一路上我们会介绍许多构建REST frmaework的组件，并且让你有一个全面的认识，这些组件是如何组建在一起的。","text":"介绍这个教程将创建一套简单的代码高亮的pastebin的Web API。一路上我们会介绍许多构建REST frmaework的组件，并且让你有一个全面的认识，这些组件是如何组建在一起的。这个教程相当’深奥’，在开始学习之前你大概需要准备一些饼干和一杯你最爱的啤酒。你如果只是想快速了解，你可以查看之前的快速入门文档。 注意：教程中的代码可以访问github地址，完整的代码：这里 设置新环境在我们开始之前，我们会使用virtualenv创建一个新的虚拟环境。这可以很好的将我们的项目与其他项目隔离开。 12virtualenv envsource env/bin/activate 现在我们已经进入虚拟环境，我们可以安装一些依赖包了。 123pip install djangopip install djangorestframeworkpip install pygments # 我们将使用这个使代码高亮 注意：退出虚拟环境可以输入deactivate。更多信息，请看virtualenv文档 准备开始我们已经准备开始敲代码了。开始前，让我们先创建一个新的项目。 123cd ~django-admin.py startproject tutorialcd tutorial 一旦完成，我们可以创建一个app，我们将使用它来创建一套简单的Web API。 1python manage.py startapp snippets 我们需要将snippetsapp和rest_frameworkapp添加到INSTALLED_APPS中。编辑tutorial/settings.py文件： 12345INSTALLED_APPS = ( ... 'rest_framework', 'snippets.apps.SnippetsConfig',) Okay,我们已经准备好了~ 创建一个模型出于本教程的目的，我们首先创建一个简单的Snippet模块，用于存储代码片段。编辑snippets/models.py文件： 12345678910111213141516171819from django.db import modelsfrom pygments.lexers import get_all_lexersfrom pygments.styles import get_all_stylesLEXERS = [item for item in get_all_lexers() if item[1]]LANGUAGE_CHOICES = sorted([(item[1][0], item[0]) for item in LEXERS])STYLE_CHOICES = sorted((item, item) for item in get_all_styles())class Snippet(models.Model): created = models.DateTimeField(auto_now_add=True) title = models.CharField(max_length=100, blank=True, default='') code = models.TextField() linenos = models.BooleanField(default=False) language = models.CharField(choices=LANGUAGE_CHOICES, default='python', max_length=100) style = models.CharField(choices=STYLE_CHOICES, default='friendly', max_length=100) class Meta: ordering = ('created',) 同步数据库 12python manage.py makemigrations snippetspython manage.py migrate 创建一个序列化器使用WebS API的第一件事就是提供一种将snippet实例序列化和反序列化成其他数据格式（如json）的方法。我们可以声明serializers（序列化器）来实现，这和Django的forms很像。在snippets的目录下创建一个serializers.py文件并添加如下代码： 1234567891011121314151617181920212223242526272829from rest_framework import serializersfrom snippets.models import Snippet, LANGUAGE_CHOICES, STYLE_CHOICESclass SnippetSerializer(serializers.Serializer): id = serializers.IntegerField(read_only=True) title = serializers.CharField(required=False, allow_blank=True, max_length=100) code = serializers.CharField(style=&#123;'base_template': 'textarea.html'&#125;) linenos = serializers.BooleanField(required=False) language = serializers.ChoiceField(choices=LANGUAGE_CHOICES, default='python') style = serializers.ChoiceField(choices=STYLE_CHOICES, default='friendly') def create(self, validated_data): \"\"\" 创建并返回一个Snippet实例 \"\"\" return Snippet.objects.create(**validated_data) def update(self, instance, validated_data): \"\"\" 更新并返回一个已经存在Snippet实例 \"\"\" instance.title = validated_data.get('title', instance.title) instance.code = validated_data.get('code', instance.code) instance.linenos = validated_data.get('linenos', instance.linenos) instance.language = validated_data.get('language', instance.language) instance.style = validated_data.get('style', instance.style) instance.save() return instance 序列化器的第一部分是定义序列化/反序列化的字段。create（）和update（）方法定义了当调用serializer.save（）是一个实例是如何被创建或更新的。 序列化器类(serializer)很像Django的Form，同时在各个字段中也包含了类似的验证标志，如required，max_length和default。 在某些情况下，字段标志也可以控制序列化后如何显示，例如渲染成HTML。上面的{&#39;base_template&#39;: &#39;textarea.html&#39;}标志等同于在DjangoForm类中使用widget=widgets.Textarea。这对于控制如何显示browsable API特别有用，正如我们将在教程后面看到的。 事实上，我们可以通过使用ModelSerializer类节省开发时间，稍后我们会看到，但是现在我们仍把注意力放在序列化器的明确定义上。 使用序列化器我们先熟悉一下我们的新序列化器如何使用。进入Django shell 1python manage.py shell Okay,导入一些必要的东西，让我们创建两个代码片段12345678910from snippets.models import Snippetfrom snippets.serializers import SnippetSerializerfrom rest_framework.renderers import JSONRendererfrom rest_framework.parsers import JSONParsersnippet = Snippet(code='foo = \"bar\"\\n')snippet.save()snippet = Snippet(code='print \"hello, world\"\\n')snippet.save() 我们现在已经有两个可用的代码片端实例，将其中一个序列化试试看。 123serializer = SnippetSerializer(snippet)serializer.data# &#123;'id': 2, 'title': u'', 'code': u'print \"hello, world\"\\n', 'linenos': False, 'language': u'python', 'style': u'friendly'&#125; 我们已经将模型实例转换成Python原生的数据类型。为了完成序列化工作，我们将数据渲染成json。 123content = JSONRenderer().render(serializer.data)content# '&#123;\"id\": 2, \"title\": \"\", \"code\": \"print \\\\\"hello, world\\\\\"\\\\n\", \"linenos\": false, \"language\": \"python\", \"style\": \"friendly\"&#125;' 反序列化也一样。我们将流解析成Python原生类型… 1234from django.utils.six import BytesIOstream = BytesIO(content)data = JSONParser().parse(stream) …然后我们把原生类型还原成一个完整的对象实例 1234567serializer = SnippetSerializer(data=data)serializer.is_valid()# Trueserializer.validated_data# OrderedDict([('title', ''), ('code', 'print \"hello, world\"\\n'), ('linenos', False), ('language', 'python'), ('style', 'friendly')])serializer.save()# &lt;Snippet: Snippet object&gt; 注意表单类型的API是如何工作的。当我们使用序列化器写视图函数时，相似之处会变得更加明显。 我们也可以对一个querysets进行序列化。只需在序列化器的参数中添加一个many=True的标志。 123serializer = SnippetSerializer(Snippet.objects.all(), many=True)serializer.data# [OrderedDict([('id', 1), ('title', u''), ('code', u'foo = \"bar\"\\n'), ('linenos', False), ('language', 'python'), ('style', 'friendly')]), OrderedDict([('id', 2), ('title', u''), ('code', u'print \"hello, world\"\\n'), ('linenos', False), ('language', 'python'), ('style', 'friendly')]), OrderedDict([('id', 3), ('title', u''), ('code', u'print \"hello, world\"'), ('linenos', False), ('language', 'python'), ('style', 'friendly')])] 使用ModelSerializers我们的SnippetSerializer类太臃肿了，要是能再简洁一点就更好了。 Django提供了Form类ModelForm类，同样的，RESTframework也有Serializer和ModelSerializer。 现在让我们用ModelSerializer重构我们序列化器吧。再次打开snippets/serializer.py，将SnippetSetializer类替换为一下代码。 1234class SnippetSerializer(serializers.ModelSerializer): class Meta: model = Snippet fields = ('id', 'title', 'code', 'linenos', 'language', 'style') 还有一个不错的特性就是你可以通过打印序列化器实例来查看所有字段信息。打开Django shell，输入一下命令： 12345678910from snippets.serializers import SnippetSerializerserializer = SnippetSerializer()print(repr(serializer))# SnippetSerializer():# id = IntegerField(label='ID', read_only=True)# title = CharField(allow_blank=True, max_length=100, required=False)# code = CharField(style=&#123;'base_template': 'textarea.html'&#125;)# linenos = BooleanField(required=False)# language = ChoiceField(choices=[('Clipper', 'FoxPro'), ('Cucumber', 'Gherkin'), ('RobotFramework', 'RobotFramework'), ('abap', 'ABAP'), ('ada', 'Ada')...# style = ChoiceField(choices=[('autumn', 'autumn'), ('borland', 'borland'), ('bw', 'bw'), ('colorful', 'colorful')... 记住，ModelSerializer类并没有做什么特别的事情，它只是一个创建序列化器的捷径： 自动判定字段类型 简单实现create（）和update（）方法 使用序列化器编写常规的Django视图目前我们不会使用任何RESTframework的其他特性，我们只是编写Djang常规的视图函数。编辑snippets/views.py文件，并添加以下代码。 123456from django.http import HttpResponse, JsonResponsefrom django.views.decorators.csrf import csrf_exemptfrom rest_framework.renderers import JSONRendererfrom rest_framework.parsers import JSONParserfrom snippets.models import Snippetfrom snippets.serializers import SnippetSerializer 首页是列出所有已存在的代码片段，或创建新的代码片段。 1234567891011121314151617@csrf_exemptdef snippet_list(request): \"\"\" List all code snippets, or create a new snippet. \"\"\" if request.method == 'GET': snippets = Snippet.objects.all() serializer = SnippetSerializer(snippets, many=True) return JsonResponse(serializer.data, safe=False) elif request.method == 'POST': data = JSONParser().parse(request) serializer = SnippetSerializer(data=data) if serializer.is_valid(): serializer.save() return JsonResponse(serializer.data, status=201) return JsonResponse(serializer.errors, status=400) 注意，因为我们希望允许没有CSRF令牌的客户端可以通过POST访问该视图，所以我们需要添加装饰器csrf_exempt。正常情况下你不该这么做，REST framework视图函数实际上还有比这更合理的解决方法，但目前这已经达到我们的目的了。 同样，我们创建一个显示单个代码片段的页面，允许搜索，更新和删除代码片段。 12345678910111213141516171819202122232425@csrf_exemptdef snippet_detail(request, pk): \"\"\" Retrieve, update or delete a code snippet. \"\"\" try: snippet = Snippet.objects.get(pk=pk) except Snippet.DoesNotExist: return HttpResponse(status=404) if request.method == 'GET': serializer = SnippetSerializer(snippet) return JsonResponse(serializer.data) elif request.method == 'PUT': data = JSONParser().parse(request) serializer = SnippetSerializer(snippet, data=data) if serializer.is_valid(): serializer.save() return JsonResponse(serializer.data) return JsonResponse(serializer.errors, status=400) elif request.method == 'DELETE': snippet.delete() return HttpResponse(status=204) 最后我们需要整合这些视图。创建snippets/urls.py文件： 12345678910111213141516from django.urls import pathfrom snippets import viewsurlpatterns = [ path('snippets/', views.snippet_list), path('snippets/&lt;int:pk&gt;/', views.snippet_detail),]# Django-2.0以下版本# from django.conf.urls import url# from snippets import views# urlpatterns = [# url(r'^snippets/$', views.snippet_list),# url(r'^snippets/(?P&lt;pk&gt;[0-9]+)/$', views.snippet_detail),# ] 将上面的url配置整合到根url配置文件中tutorial/urls.py。 1234567891011121314from django.contrib import adminfrom django.urls import pathfrom django.conf.urls import includeurlpatterns = [ path('admin/', admin.site.urls), path('', include('snippets.urls')),]# 2.0以下# from django.conf.urls import url, include## urlpatterns = [# url(r'^', include('snippets.urls')),# ] 目前，我们还有许多边界条件没有处理。如果我们发送的json格式不正确，或者请求一个视图无法处理的方法时，我们会返回一个500 server error。 测试我们在Web API上的第一次尝试现在我们可以启动服务器运行我们服务了。先退出刚刚的shell… 1quit() …接着启动我们的服务器 12345678python manage.py runserverValidating models...0 errors foundDjango version 1.11, using settings &apos;tutorial.settings&apos;Development server is running at http://127.0.0.1:8000/Quit the server with CONTROL-C. 在另一个终端窗口，来测试我们的服务。 我们可以使用curl或者httpie来测试。Httpie是由python实现的一款的http客户端。 你可以通过pip来安装它： 1pip install httpie 接着，我们尝试获取所有代码片段的列表 12345678910111213141516171819202122http http://127.0.0.1:8000/snippets/HTTP/1.1 200 OK...[ &#123; \"id\": 1, \"title\": \"\", \"code\": \"foo = \\\"bar\\\"\\n\", \"linenos\": false, \"language\": \"python\", \"style\": \"friendly\" &#125;, &#123; \"id\": 2, \"title\": \"\", \"code\": \"print \\\"hello, world\\\"\\n\", \"linenos\": false, \"language\": \"python\", \"style\": \"friendly\" &#125;] 或者我们可以通过它的id来访问单个代码片段: 123456789101112http http://127.0.0.1:8000/snippets/2/HTTP/1.1 200 OK...&#123; \"id\": 2, \"title\": \"\", \"code\": \"print \\\"hello, world\\\"\\n\", \"linenos\": false, \"language\": \"python\", \"style\": \"friendly\"&#125; 同样地，你可以通过浏览器访问URLs来获得这些json数据。 我们到什么程度了目前为止我们表现还不错，我们已经有了一个序列化的API，这感觉跟Django的表单API和一些常规的Django视图非常相似。 除了返回json数据，我们的视图没有做什么特别的事。还有一些边界条件的处理没有实现，但这仍是一个正常运行的Web API。 我们将在教程2开始改进它。 原文：http://www.django-rest-framework.org/tutorial/1-serialization/#working-with-serializers","categories":[],"tags":[{"name":"Django","slug":"Django","permalink":"http://yoursite.com/tags/Django/"},{"name":"Django REST framework","slug":"Django-REST-framework","permalink":"http://yoursite.com/tags/Django-REST-framework/"},{"name":"翻译","slug":"翻译","permalink":"http://yoursite.com/tags/翻译/"}]},{"title":"Django RESTful framework快速入门","slug":"Django-RESTful-framework快速入门","date":"2018-02-05T16:22:15.000Z","updated":"2018-02-08T07:52:36.170Z","comments":true,"path":"2018/02/06/Django-RESTful-framework快速入门/","link":"","permalink":"http://yoursite.com/2018/02/06/Django-RESTful-framework快速入门/","excerpt":"快速入门我们会创建一套简单的API来允许管理员查看和编辑系统中的用户和用户组","text":"快速入门我们会创建一套简单的API来允许管理员查看和编辑系统中的用户和用户组 创建项目创建一个新的Django项目tutorial，然后创建一个新的appquickstart。1234567891011121314151617# Create the project directorymkdir tutorialcd tutorial# Create a virtualenv to isolate our package dependencies locallyvirtualenv envsource env/bin/activate # On Windows use `env\\Scripts\\activate`# Install Django and Django REST framework into the virtualenvpip install djangopip install djangorestframework# Set up a new project with a single applicationdjango-admin.py startproject tutorial . # Note the trailing &apos;.&apos; charactercd tutorialdjango-admin.py startapp quickstartcd .. 项目的结果应该像这样：12345678910111213141516171819$ pwd&lt;some path&gt;/tutorial$ find .../manage.py./tutorial./tutorial/__init__.py./tutorial/quickstart./tutorial/quickstart/__init__.py./tutorial/quickstart/admin.py./tutorial/quickstart/apps.py./tutorial/quickstart/migrations./tutorial/quickstart/migrations/__init__.py./tutorial/quickstart/models.py./tutorial/quickstart/tests.py./tutorial/quickstart/views.py./tutorial/settings.py./tutorial/urls.py./tutorial/wsgi.py 这看起来可能有些不寻常，在项目目录中创建了应用程序。使用项目命名空间避免扩展模块的命名冲突。 现在第一次同步你的数据库：1python manage.py migrate 我们还将创建一个初始用户user，密码是password123。在稍后的例子中我们会认证该用户。1python manage.py createsuperuser --email admin@example.com --username admin 一旦你建立一个数据库和一个初始用户并且已经准备好，打开app目录然后开始敲码… 序列化器首先我们会定义一些序列号器。让我创建一个新的模块tutorial/quickstart/serializers.py我们将会使用它们来表示我们的数据。1234567891011121314from django.contrib.auth.models import User, Groupfrom rest_framework import serializersclass UserSerializer(serializers.HyperlinkedModelSerializer): class Meta: model = User fields = ('url', 'username', 'email', 'groups')class GroupSerializer(serializers.HyperlinkedModelSerializer): class Meta: model = Group fields = ('url', 'name') 注意我们在这个例子中使用了超链接关系，通过HyperlinkedModelSerializer。你也可以使用主键和其他关系，但是超链接是良好的RESTful设计。 视图是的，我们最好写一些视图。打开tutorial/quickstart/views.py然后输入：12345678910111213141516171819from django.contrib.auth.models import User, Groupfrom rest_framework import viewsetsfrom tutorial.quickstart.serializers import UserSerializer, GroupSerializerclass UserViewSet(viewsets.ModelViewSet): \"\"\" API endpoint that allows users to be viewed or edited. \"\"\" queryset = User.objects.all().order_by('-date_joined') serializer_class = UserSerializerclass GroupViewSet(viewsets.ModelViewSet): \"\"\" API endpoint that allows groups to be viewed or edited. \"\"\" queryset = Group.objects.all() serializer_class = GroupSerializer 我们不是写许多视图，而是将所有常见的行为分组成类ViewSets。 如果我们需要，我们可以很容易的把这些分解为单独的视图，但是使用viewsets维护视图逻辑易于管理也非常简洁。 URLsOkay，现在让我将API接到URLs。打开tutorial/urls.py…1234567891011121314from django.conf.urls import url, includefrom rest_framework import routersfrom tutorial.quickstart import viewsrouter = routers.DefaultRouter()router.register(r'users', views.UserViewSet)router.register(r'groups', views.GroupViewSet)# Wire up our API using automatic URL routing.# Additionally, we include login URLs for the browsable API.urlpatterns = [ url(r'^', include(router.urls)), url(r'^api-auth/', include('rest_framework.urls', namespace='rest_framework'))] 因为我们使用viewsets代替普通的视图，所以通过简单地将viewsets注册为一个路由类，我们可以为我们API自动地生成URL配置。 如果我们需要对API URLs有更多操作，我们可以使用普通的视图并且明确地编写URL配置文件。 最后，我们通过browsable API包含了默认的登陆和注销视图。这是可选的，但是如果你的API需要认证功能和你想使用browsable API，这将非常有用。 设置把rest_framework添加到INSTALLED_APPS。设置模块在tutorial/settings.py 1234INSTALLED_APPS = ( ... 'rest_framework',) Okay，我们完成了。 测试我们的API我们现在准备测试我们刚刚创建的API。让我们通过命令行启动服务器。1python manage.py runserver 我们可以访问我们的API，通过命令行或者使用工具：curl…1234567891011121314151617181920bash: curl -H &apos;Accept: application/json; indent=4&apos; -u admin:password123 http://127.0.0.1:8000/users/&#123; &quot;count&quot;: 2, &quot;next&quot;: null, &quot;previous&quot;: null, &quot;results&quot;: [ &#123; &quot;email&quot;: &quot;admin@example.com&quot;, &quot;groups&quot;: [], &quot;url&quot;: &quot;http://127.0.0.1:8000/users/1/&quot;, &quot;username&quot;: &quot;admin&quot; &#125;, &#123; &quot;email&quot;: &quot;tom@example.com&quot;, &quot;groups&quot;: [ ], &quot;url&quot;: &quot;http://127.0.0.1:8000/users/2/&quot;, &quot;username&quot;: &quot;tom&quot; &#125; ]&#125; 或者使用httpie，命令行工具…1234567891011121314151617181920212223bash: http -a admin:password123 http://127.0.0.1:8000/users/HTTP/1.1 200 OK...&#123; &quot;count&quot;: 2, &quot;next&quot;: null, &quot;previous&quot;: null, &quot;results&quot;: [ &#123; &quot;email&quot;: &quot;admin@example.com&quot;, &quot;groups&quot;: [], &quot;url&quot;: &quot;http://localhost:8000/users/1/&quot;, &quot;username&quot;: &quot;paul&quot; &#125;, &#123; &quot;email&quot;: &quot;tom@example.com&quot;, &quot;groups&quot;: [ ], &quot;url&quot;: &quot;http://127.0.0.1:8000/users/2/&quot;, &quot;username&quot;: &quot;tom&quot; &#125; ]&#125; 或者直接使用浏览器访问http://127.0.0.1:8000/users/… 如果你使用浏览器，首先确保你已经通过右上角登陆。 好的，就是这么简单！ 如果你想更深入了解，可以浏览API guide 原文：http://www.django-rest-framework.org/tutorial/quickstart/#quickstart","categories":[],"tags":[{"name":"Django","slug":"Django","permalink":"http://yoursite.com/tags/Django/"},{"name":"Django RESTful framewo","slug":"Django-RESTful-framewo","permalink":"http://yoursite.com/tags/Django-RESTful-framewo/"}]},{"title":"数据库建模","slug":"数据库建模","date":"2018-01-07T02:51:38.000Z","updated":"2018-02-08T06:16:10.857Z","comments":true,"path":"2018/01/07/数据库建模/","link":"","permalink":"http://yoursite.com/2018/01/07/数据库建模/","excerpt":"一.数据库设计过程","text":"一.数据库设计过程 需求分析 概念设计 逻辑设计 模式求精 物理设计 应用与安全设计 二.E-R模型基本概念(实体集,联系集,属性)1. 实体与实体集2. 属性及其分类 简单属性,复合属性 单值属性,多值属性 派生属性 3. 联系与联系集 多联系:各实体之间可以有多种不同的联系. 实体的角色:当同一个实体集在一个联系集中参与的次数大于一次,且每次以不同的角色参与时,要用显示的角色名定义一个实体参与联系的方式. 联系集的度:联系集的实体集的数目. 三.约束1. 映射约束 一对一 一对多 多对一 多对多 2. 码约束①实体集的码 超码:唯一标识一个实体的一个或多个属性的集合. 候选码:一个超码的任意真子集都不能成为超码,这样最小的超码成为候选码. 主码:从多个候选码中选择一个作为实体集的主码. ②主码选择原则 选择属性长度最短的候选码 尽量选择包含单个属性的码,而不是复合候选码 选择在数据库系统生命周期内属性值最少变化的候选码 选择在数据库系统生命周期内更可能包含唯一值的候选码 ③联系集的码 每一个联系集必须存在候选码并选择其中的一个候选码作为主码 一对一联系集:主码可以使用任何一方实体集的主码一对多(多对一)联系集:主码由”多”的一方实体集的主码组成多对多联系集:主码由参与联系集中所有实体集的主码组成 ④联系集的属性安置一对一联系集的属性:可安置在任一边的实体集上一对多联系集的属性:可安置于联系集上,也可安置在多的那一边的实体集上多对多联系集的属性:只能安置在联系集上,不能放到相关联的实体集上 3. 依赖约束依赖实体集:联系中的一种实体的存在依赖于该联系集中联系的存在 如:销货单实体集与商品销售联系集弱实体集:联系中的一种实体的存在依赖于其他实体集中实体的存在 如:开课班实体集与课程实体集 4. 参与约束实体集与联系集: 全部参与 部分参与 5. 多值联系同一个给定的联系集中,相关联的相同实体之间可能存在多个联系,如客户与银行之间多对多贷款联系集,及同时一个银行可以向多个客户发放贷款的一对多联系集. 四.弱实体集某些实体集的属性不足以形成主码,他们必须依赖于其他实体集的存在而存在. 部分码:用来标识弱实体的属性弱实体集中的实体是由标识实体集中的主码与其部分码共同标识. 五.扩展E-R特征1. 类的层次E-R模型使用实体集的继承和ISA联系来描述这种概念上的继承.ISA关系可以从两个方向进行设计:①自上而下,先设计父类实体集,再将父类具体化为其他子类②自下而上,先具体化子类实体集,再将子类中的共同属性提取出来,泛化为父类 2. 聚合聚合是一种抽象,它将一个联系集及其相关联的实体集抽象为一个联系实体集对待,然后建立该联系实体集与其他实体集之间的联系集. 六.E-R建模问题E-R建模的基本原则1.忠实性: 设计应忠实于应用需求2.简单性: 除非有绝对需要,否则不要在设计中增加更多成分3.避免冗余: 一个对象只存放在一个地方4.选择实体集还是属性:①不可再分②不能和其他实体相联系满足上述两条规则均可作为属性对待5.选择实体集还是联系集:实体集一般对应现实生活中实际存在的事物联系集一般对应一种动作6.多元联系转化为二元联系: 依赖约束的建模多值联系的建模 将多值联系建模为弱实体集 将多值联系建模为依赖实体集 E-R模型的表示 实体集:矩形 弱实体集:双矩形 属性:椭圆 多值属性:双椭圆 派生属性:虚线椭圆 联系(集):菱形 标识联系集:双菱形 属性与实体之间用连线表示 加下划线的属性为实体集的主码 虚下划线表示弱实体的部分码 “→”指向参与联系集中”一”方实体集,”-“指向参与联系集”多”方实体集 联系实体集:带菱形的矩形","categories":[],"tags":[{"name":"review","slug":"review","permalink":"http://yoursite.com/tags/review/"},{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/数据库/"}]},{"title":"乐观锁-悲观锁","slug":"乐观锁-悲观锁","date":"2017-05-21T08:39:48.000Z","updated":"2018-02-08T06:15:35.475Z","comments":true,"path":"2017/05/21/乐观锁-悲观锁/","link":"","permalink":"http://yoursite.com/2017/05/21/乐观锁-悲观锁/","excerpt":"","text":"悲观锁对数据被外界修改持保守态度，在整个数据处理过程中，将数据处于锁定状态。其实现依靠数据库的锁机制，以保证操作最大程度的独占性。但随之而来的就是数据库性能的大量开销。以MySQL InnoDB为例,当使用SELECT FOR UPDATE就会使用悲观锁，前提是把事务自动提交取消1set autocommit = 0; 使用悲观锁的原理就是，当我们在查询出信息后就把当前的数据锁定，直到我们修改完毕后再解锁。根据查询条件的不同，锁定的范围也不同 当查询条件中指定明确主键，并且有此数据——–行级锁（row lock） 当查询条件中指定明确主键，但无次数据———-无锁 当查询条件中无主键————————-表级锁（table lock） 当查询条件中主键不明确———————-表级锁（table lock） 乐观锁乐观锁大多基于数据版本记录机制实现，即为数据增加一个版本标识，在基于数据库表的版本解决方案，一般是通过为数据库表增加一个 “version” 字段来实现。也可以采用另一种方式，同样是在需要乐观锁控制的table中增加一个字段，名称无所谓，字段类型使用时间戳timestamp中，操作步骤 读取出数据时，将此版本号（时间戳）一同读出 更新时，比较数据库中该数据当前的版本号和手上的版本号，不一致说明版本冲突，一致则OK，将版本号+1或者获取当前时间戳后将数据更新回数据库 缺点乐观锁机制往往基于系统中的数据存储逻辑，那么来自外部系统的更新操作不受我们系统的控制，因此可能会造成脏数据被更新到数据库中。解决如将乐观锁策略在数据库存储过程中实现，对外只开放基于此存储过程的数据更新途径，而不是将数据库表直接对外公开 参考muyuren | mysql悲观锁详解 muyuren | mysql乐观锁详解","categories":[],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/数据库/"}]},{"title":"Hibernate NotNull NotEmpty NotBlank区别","slug":"Hibernate-NotNull-NotEmpty-NotBlank区别","date":"2017-05-10T12:28:48.000Z","updated":"2017-05-10T12:40:45.000Z","comments":true,"path":"2017/05/10/Hibernate-NotNull-NotEmpty-NotBlank区别/","link":"","permalink":"http://yoursite.com/2017/05/10/Hibernate-NotNull-NotEmpty-NotBlank区别/","excerpt":"","text":"@NotNull不允许为null，但可以是empty @NotEmpty不允许为null且长度要大于0 @NotBlank只能作用在String上，不能为null，而且调用trim()后，长度必须大于0 例子12345678910111213141516171819String name = null;NotNull = falseNotEmpty = falseNotBlank = falseString nam = \"\";NotNull = trueNotEmpty = falseNotBlank = falseString name = \" \";NotNull = trueNotEmpty = trueNotBlank = falseString name = \"zojian\"NotNull = trueNotEmpty = trueNotBlank = true","categories":[],"tags":[{"name":"Hibernate","slug":"Hibernate","permalink":"http://yoursite.com/tags/Hibernate/"}]},{"title":"Spring4基于注解加载properties文件方式","slug":"Spring4注入properties文件方式","date":"2017-05-09T13:24:08.000Z","updated":"2017-05-09T13:28:41.000Z","comments":true,"path":"2017/05/09/Spring4注入properties文件方式/","link":"","permalink":"http://yoursite.com/2017/05/09/Spring4注入properties文件方式/","excerpt":"","text":"@PropertySource注解将properties配置文件中的值存储到Spring的 Environment中，Environment接口提供方法去读取配置文件中的值，参数是properties文件中定义的key值 1234@PropertySource(\"classpath:message.properties\")public class AppConfig extends WebMvcConfigurerAdapter &#123; //something&#125; 多个配置文件@PropertySources注解1234567@PropertySources(&#123; @PropertySource(\"classpath:config.properties\"), @PropertySource(\"classpath:db.properties\")&#125;)public class AppConfig &#123; //something&#125; ignoreResourceNotFound属性如果*.properties不存在或找不到,系统则会抛出异常FileNotFoundException。但是ignoreResourceNotFound设为true之后会忽略找不到的文件 12345@PropertySource(value=\"classpath:missing.properties\" ,ignoreResourceNotFound=true) public class AppConfig &#123; //something &#125;","categories":[],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"[读薄系列]Java并发编程的艺术笔记","slug":"Java并发编程的艺术笔记","date":"2017-05-06T12:59:04.000Z","updated":"2018-02-08T06:12:02.071Z","comments":true,"path":"2017/05/06/Java并发编程的艺术笔记/","link":"","permalink":"http://yoursite.com/2017/05/06/Java并发编程的艺术笔记/","excerpt":"","text":"1.并发编程的挑战什么是上下文切换CPU通过时间片分配算法循环执行任务[线程]，当任务执行完一个时间片后会切换到下一个任务，在切换前会保存上一个任务的状态，以便下次切换回来时可以再加载这个任务的状态。所以任务从保存到加载的过程就是一次上下文切换。 如何减少上下文切换 无锁并发编程：如数据取模分段，不同线程处理不同数据 CAS算法：Atomic包使用CAS算法来更新数据， 而不需要加锁 使用最少线程：避免创建不必要的线程，使得大多数线程处于等待状态 协程：在单线程里实现多任务调度，并在单线程里维持多个任务的切换 如何避免死锁 避免一个线程同时获得多个锁 避免一个锁同时占用多个资源 限制加锁顺序 尝试使用定时锁 lock.tryLock(timeout) 对应数据库锁，加锁和解锁必须在同一个数据库连接里 2.Java并发机制底层实现原理volatile 轻量级的synchronized，在多处理器开发中保证了共享变量的“可见性”（当一个线程修改一个共享变量时，另一个线程能读到这个修改的值）比synchronized的使用和执行成本低，因为它不会引起线程上下文的切换和调度 背景为了提高处理速度，CPU不直接和内存进行通信，而是将系统内存的数据读到内部缓存（L1,L2,L3）后再操作，但操作完不确定何时会写回内存。这样可能导致其他CPU不能获取到共享变量的最新值。 实现原理在x86处理器下通过工具获取JIT编译器生成的汇编指令来看看对Volatile进行写操作CPU 类别 代码 Java代码 instance = new Singleton(); //instance是volatile变量 汇编指令 0x01a3de1d: movb $0x0,0x1104800(%esi);0x01a3de24: lock addl $0x0,(%esp); Lock前缀的命令作两件事： 将当前CPU缓存行的数据写回到内存 令其他CPU里缓存了该内存地址的数据失效 缓存一致性协议每个CPU通过嗅探在总线中传播的数据来检查自己的缓存的值是否过期，当CPU发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当CPU对这个数据进行修改操作时，会重新从系统内存中把数据读到CPU缓存中。 使用优化LinkedTransferQueue部分源码1234567891011121314151617181920212223242526/** head of the queue */private transient final PaddedAtomicReference &lt; QNode &gt; head;/** tail of the queue */private transient final PaddedAtomicReference &lt; QNode &gt; tail;static final class PaddedAtomicReference &lt; T &gt; extends AtomicReference &lt; T &gt; &#123; // enough padding for 64bytes with 4byte refs Object p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, pa, pb, pc, pd, pe; PaddedAtomicReference(T r) &#123; super(r); &#125;&#125;public class AtomicReference &lt; V &gt; implements java.io.Serializable &#123; private volatile V value; //省略其他代码 ｝ 因为缓存行是64个字节且不支持部分填充缓存，这意味着，如果队头队尾不足64字节，有可能他们会读到同一个缓存行中，那么有可能在修改头结点时，会将整个缓存行锁定，使得其他CPU无法访问尾节点，导致效率低下。在PaddedAtomicReference内部类中将共享变量追加到64字节，使得头结点和尾节点不会加载同一个缓存行，即不会互相锁定。 不适合使用这种优化的情景 缓存行非64字节的CPU 共享变量不会被频繁地写 synchronizedliuxiaopeng | Java并发编程：Synchronized底层优化（偏向锁、轻量级锁） 原子操作 不可被中断的一个或一系列操作 CPU实现原子操作总线锁定使用CPU提供的一个LOCK#信号，当一个CPU在总线上输出此信号时，其他CPU的请求将会被阻塞，那么该CPU就能独享共享内存了 缓存锁定内存区域如果被缓存在处理器的缓存行中，并且在Lock操作期间被锁定，那么当它执行锁操作回写到内存时，处理器不需要在总线上声言LOCK#信号，而是修改内部的内存地址，通过缓存一致性机制保证操作的原子性。例外：当操作的数据不能被缓存在处理器内部，或操作的数据跨多个缓存行，处理器会调用总线锁定。或者处理器不支持缓存 Java实现原子操作循环CAS（CompareAndSet|CompareAndSwap）jvm中的CAS操作是基于处理器的CMPXCHG指令实现的，CAS存在三个问题： ABA问题（解决：使用版本号A-B-A变成1A-2B-3A） 循环时间长开销大 只能保证一个共享变量的原子操作（解决：AtomicReference类将多个变量放到一个对象中进行CAS操作） 锁锁机制保证了只有获得锁的线程才能操作锁定的内存区域","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Java并发","slug":"Java并发","permalink":"http://yoursite.com/tags/Java并发/"},{"name":"读薄系列","slug":"读薄系列","permalink":"http://yoursite.com/tags/读薄系列/"}]},{"title":"Hibernate缓存小结","slug":"Hibernate缓存小结","date":"2017-05-03T09:17:30.000Z","updated":"2017-05-03T11:53:45.000Z","comments":true,"path":"2017/05/03/Hibernate缓存小结/","link":"","permalink":"http://yoursite.com/2017/05/03/Hibernate缓存小结/","excerpt":"","text":"什么是缓存 缓存是介于应用程序和物理数据源之间，其作用是为了降低应用程序对物理数据源访问的频次，从而提高了应用的运行性能。缓存内的数据是对物理数据源中的数据的复制，应用程序在运行时从缓存读写数据，在特定的时刻或事件会同步缓存和物理数据源的数据。 一级缓存（会话级） 存放在session中，数据适用范围在当前session内 生命周期与当前session相同 默认启用 evict()方法：用于将某个对象从Session的一级缓存中清除 clear()方法：用于将一级缓存中的所有对象全部清楚 二级缓存（应用级） 数据可使用范围是当前应用的所有会话 默认不启用，选择性开启（默认是EHCache，其他二级缓存组件如：HashTable、OSCache、SwarmCache等。） 由sessionFactory控制 N+1次问题订单表(ORDERS) ID ORDER_NUMBER CUSTOMER_ID 1 TOM 1 2 TOM 1 3 JAY 2 4 ALICE 3 客户表(CUSTOMERS) ID NAME 1 TOM 2 JAY 3 ALICE 订单表和客户表是多对一的关系，当检索所有客户时将依次执行以下SQL语句 select from CUSTOMERS;select from ORDERS where CUSTOMER_ID=1;select from ORDERS where CUSTOMER_ID=2;select from ORDERS where CUSTOMER_ID=3; N+1问题解决方案 使用表连接查询 select * from CUSTOMERS left outer join ORDERS on CUSTOMERS.ID=ORDERS.CUSTOMER_ID 使用延迟加载 fetch = FetchType.lazy 在关联对象类上标注@BatchSize(size=x) , 设置管理对象查询时一次性查询多少条记录， 使转为为 1+n/x问题。（不推荐） 适用二级缓存的情况 数据不会被第三方修改（绕过ORM会使数据不一致） 数据大小在可接收范围之内（缓存会占用内存资源，占太多反而会降低性能） 数据更新频率低（频繁的同步缓存中数据也会降低性能） 非关键数据（正确性 高于 高性能） query.list（）和query.iterator（） list（）不使用一级缓存，即每次调用都会向底层数据库查询，但是会将结果保存到一级缓存中 iterator（）会先执行一条语句向数据库取出符合条件的数据id，然后通过id在hibernate的一级缓存中查找是否存在该对象，如果存在则直接取出，如果没有则再次发出一条sql语句通过id取得对象（并且加入到缓存中），这样如果所有的id在缓存中都没有的话就会出现n+1条sql语句的问题。","categories":[],"tags":[{"name":"Hibernate","slug":"Hibernate","permalink":"http://yoursite.com/tags/Hibernate/"}]},{"title":"可能会发生重定向的情况","slug":"可能会发生重定向的情况","date":"2017-03-30T11:55:40.000Z","updated":"2018-02-08T06:15:28.939Z","comments":true,"path":"2017/03/30/可能会发生重定向的情况/","link":"","permalink":"http://yoursite.com/2017/03/30/可能会发生重定向的情况/","excerpt":"","text":"一. 永久搬离的资源访问的资源被（永久性）移动新的位置或者被（永久性）重命名，从而形成新的URL。Web服务器返回重定向响应告诉客户从新的地址获取资源，并且在访问新地址之前更新书签之类的信息。 二. 临时搬离的资源访问的资源被临时移走或临时重命名，服务器希望客户端重定向到新的位置上去，但由于资源的改变是临时的，所以服务器希望客户端将来还是可以回头去使用老的URL。不要对书签进行更新 三. URL增强通过重定向来重写URL，往往用于嵌入上下文。[经过扩展和状态增强的URL称为“胖URL”]客户端会跟随这个重定向信息，重新发起请求，但这次的请求会包含完整的、经过状态增强的URL，这是在事务间维护状态的一种有效的方法。 四. 负载均衡如果一个超载的服务器收到一条请求，服务器可以将客户端的请求重定向到一个负载不太重的服务器上去。 五. 规范目录名称客户端请求的URI是一个不带尾部斜线的目录吗时，大多数Web服务器会将客户端重定向到一个加了斜线的URI上，这样相对链接就可以正常工作了。 补充：状态码302，303，307的区别 302是HTTP/1.0的标准，303，307则是HTTP/1.1标准中对302的细化 302：如果客户端发出POST请求后，收到服务端的302状态码，那么不能自动的向新的URI发送重复请求，必须跟用户确认是否该重发，因为第二次POST时，环境可能已经发生变化（POST方法不是幂等的），POST操作会不符合用户预期 303：对于POST请求，它表示请求已经被处理，客户端可以接着使用GET方法去请求Location里的URI 307：对于POST请求，表示请求还没有被处理，客户端应该向Location里的URI重新发起POST请求","categories":[],"tags":[]},{"title":"[读薄系列]并查集","slug":"读薄系列-并查集","date":"2017-03-24T14:57:04.000Z","updated":"2018-02-08T06:15:01.255Z","comments":true,"path":"2017/03/24/读薄系列-并查集/","link":"","permalink":"http://yoursite.com/2017/03/24/读薄系列-并查集/","excerpt":"什么是并查集","text":"什么是并查集 一种树形结构，用于处理一些不相交集合的合并及查询问题主要的两种操作：合并：合并两个集合查询：查询两个元素是否属于同一个集合 存储集合中元素的关系用一个数组记录每一个元素的上一级是谁例如fa[1]=2表示1号的上一级是2号如果一个元素的上一级是自己，那么他就是这个集合的“老大”（用来唯一标识这个集合） 查询元素属于哪个集合假如现在4号元素想知道他属于哪一个集合，那么他会去问他的上一级，上一级又去问他的上一级，直到集合的“老大”查询成功时，会按原路径返回结果 12345int find(int x)&#123; if(x!=fa[x]) return find(fa[x]); return x;&#125; 合并两个集合假如现在1号和5号所在的集合想合并，两个集合合并必须先问过两个集合的“老大”123456789bool merge(int x, int y)&#123; int fx = find(x);//找“老大” int fy = find(y); if(fx!=fy)&#123;//不属于同一个集合 fa[fx] = fy; return true;//合并成功 &#125; return false;//合并失败&#125; 路径压缩在合并集合的过程是将两个集合的“老大”连接起来，谁当谁的上一级完全随机，所以最后树状结构完全有可能变成链状，这样查找效率就会比较低了。最理想的情况就是所以人的直接上级就是“老大”了，一共两级结构，只有找一次便找到集合“老大”。不一定要完全符合这个结构，只需尽量符合即可。 还是原来那个查找的例子当将结果往下传递的过程中，随带把路径中的元素的直接上一级设为集合“老大”即可。最终变为 12345int find(int x)&#123; if(x!=fa[x]) return fa[x] = find(fa[x]); return x;&#125;","categories":[],"tags":[{"name":"读薄系列","slug":"读薄系列","permalink":"http://yoursite.com/tags/读薄系列/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"},{"name":"并查集","slug":"并查集","permalink":"http://yoursite.com/tags/并查集/"}]},{"title":"[读薄系列]RMQ问题之ST算法","slug":"RMQ问题之ST算法","date":"2017-03-23T01:54:29.000Z","updated":"2017-03-24T15:04:48.000Z","comments":true,"path":"2017/03/23/RMQ问题之ST算法/","link":"","permalink":"http://yoursite.com/2017/03/23/RMQ问题之ST算法/","excerpt":"","text":"什么是ST算法ST（Sparse Table，稀疏表）是解决RMQ问题的经典在线算法O(NlogN)预处理O(1)查询本质就是动态规划算法 预处理维护二维数组ST[n][n]，ST[i][j]表示i开始，长度为2j的子数组中的最值在求ST[i][j]的最值时，将这段子数组切成两半，每段长度为2j-1，于是前面一段的最值为ST[i][j-1]，后面一段的最值为ST[i+2j-1][j-1]，即状态转移方程为ST[i][j] = max(ST[i][j-1], ST[i+2j-1][j-1]) 123456789void initST()&#123; for (int i = 0; i &lt; n; i++) ST[i][0] = num[i]; for(int j = 1; (1&lt;&lt;j) &lt;= n; j++)&#123;//枚举长度 for(int i = 0; i + (1&lt;&lt;j) - 1 &lt; n;i++)&#123;//枚举起点 ST[i][j] = max(ST[i][j-1], ST[i+(1&lt;&lt;(j-1))][j-1]); &#125; &#125;&#125; 查询由于每次查询的区间长度不一定是偶数，即不能直接用ST[i][j]表示，所以还需进一步处理。对于查询区间[a，b]，我们将其分为两段长度相等（2k）的偶数区间,他们可能相交，但不影响最值的求解，即(b-a)/2 ≤ 2k ≤ b-a+1所以k的最小值为log2(b-a)即query(a, b) = max(ST[a][k], ST[b - (2k + 1)][k])1234int query(int a,int b)&#123; int k = (int)(log(b-a+1.0)/log(2.0)); return max(ST[u][k],ST[b-(1&lt;&lt;k)+1][k]);&#125; 动态修改当修改某个位置的数值时，需要将覆盖此位置的所有区间做相应的更新 更新ST[i][0] 枚举长度 j=1；2j ≤ n；j++ 枚举起点从以i为最后一个元素的区间到以i为起点的区间 123456789void update(int x, int y)&#123; ST[x][0] = y; for(int j = 1; (1&lt;&lt;j) &lt;= n; j++)&#123; for(int i = x-(1&lt;&lt;j)+1 &gt; 1 ? x-(1&lt;&lt;j)+1 : 1; i &lt;= x &amp;&amp; i + (1&lt;&lt;j)-1 &lt;= n; i++) ST[i][j] = max(ST[i][j-1], ST[i + (1&lt;&lt;(j-1))][j-1]); &#125;&#125;","categories":[],"tags":[{"name":"DP","slug":"DP","permalink":"http://yoursite.com/tags/DP/"},{"name":"读薄系列","slug":"读薄系列","permalink":"http://yoursite.com/tags/读薄系列/"},{"name":"RMQ","slug":"RMQ","permalink":"http://yoursite.com/tags/RMQ/"},{"name":"ST","slug":"ST","permalink":"http://yoursite.com/tags/ST/"}]},{"title":"[Codeforces777a]Shell Game","slug":"Codeforces777a-Shell-Game","date":"2017-03-12T04:48:51.000Z","updated":"2017-03-12T05:19:22.000Z","comments":true,"path":"2017/03/12/Codeforces777a-Shell-Game/","link":"","permalink":"http://yoursite.com/2017/03/12/Codeforces777a-Shell-Game/","excerpt":"","text":"题目传送门 题意游戏规则：三个杯子一个球，知道杯子交换的次数和最后球所在的位置，问初始球在哪一个杯子中。杯子交换的规制： 左边杯子和中间的杯子交换（第奇数次交换） 右边杯子和中间的杯子交换（第偶数次交换） 思路由于杯子数目是固定的，且交换有规则，可以先尝试下前几次交换的情况初始 0 1 2 第一次交换 1 0 2 第二次交换 1 2 0 第三次交换 2 1 0 第四次交换 2 0 1 第五次交换 0 2 1 第六次交换 0 1 2 发现6次交换后杯子又恢复到初始的位置所以可以将这6种情况的位置情况存到一个二维数组ans[][]，根据交换次数n和最终位置x可得出初始位置是ans[n%6][x] 代码12345678910111213141516171819202122#include&lt;iostream&gt;using namespace std;int ans[7][3] = &#123; 0,1,2, 1,0,2, 1,2,0, 2,1,0, 2,0,1, 0,2,1, 0,1,2&#125;;int main() &#123; __int64 n; int x; while (cin &gt;&gt; n &gt;&gt; x) &#123; n %= 6; cout &lt;&lt; ans[n][x] &lt;&lt; endl; &#125; return 0;&#125;","categories":[],"tags":[{"name":"CodeForces","slug":"CodeForces","permalink":"http://yoursite.com/tags/CodeForces/"}]},{"title":"脑力游戏","slug":"脑力游戏","date":"2017-03-11T02:04:52.000Z","updated":"2017-03-11T02:16:16.000Z","comments":true,"path":"2017/03/11/脑力游戏/","link":"","permalink":"http://yoursite.com/2017/03/11/脑力游戏/","excerpt":"","text":"脑力游戏题目大意给定n个带锁的盒子和n把钥匙，每把钥匙对应着唯一的一个盒子。初始状态下每把钥匙分别放在不同的盒子中，且所有盒子是上锁的。可以通过“暴力”打开某些盒子，取出放在里面的钥匙，然后利用拿到的钥匙去开相应的盒子。问如果只允许“暴力”打开最多k个盒子，那么在多少种状态下，可以最终打开所有盒子。(1≤n≤100, 0≤k≤n) 涉及知识点置换1.什么是置换假设S={1,2,3,.., n}，σ是S上的双射函数，则S上的n元置换记为σ $$ \\left( \\begin{matrix} 1 &amp; 2 &amp; … &amp; n \\ σ(1) &amp; σ(2) &amp; … &amp; σ(n) \\end{matrix} \\right)$$ 2.什么是轮换设σ是S上的n元置换，若σ(i1)=i2,σ(i2)=i3 ,…, σ(ik-1)=ik,σ(ik)=i1且保持S中的其他元素不变，则称σ为S上的k阶轮换，记作(i1 i2 … ik),若k=2，称σ为S上的对换。 3.置换和轮换的关系任何n元置换可以分解为不相交的轮换之积。$$ \\left( \\begin{matrix} 1 &amp; 2 &amp; 3 &amp; 4 &amp; 5 &amp; 6 &amp; 7 &amp; 8 \\ 5 &amp; 3 &amp; 6 &amp; 4 &amp; 2 &amp; 1 &amp; 8 &amp; 7 \\end{matrix} \\right)$$拆成(1 5 2 3 6)(4)(7 8) 动态规划1.判断一个问题是否可以用动态规划解决 具有最优子结构 具有重叠子问题 无后效性 2.什么是最优子结构 一个问题的最优解包含其子问题的最优解 局部最优解能解决全局最优解 3.什么重叠子问题 每次产生的子问题并不总是新问题，有些子问题会被重复计算多少 而分治产生的子问题都是相互独立的 4.什么是无后效性 某个状态以后的过程不会影响到以前的过程 5.处理动态规划问题的步骤 定义最优子结构 把问题看作多阶段决策的过程来求解问题 递归定义最优解 按自定向上的方式解最优解 解题思路 n把钥匙的不同放置方法实际上对应1~n的不同的排列。 第一次暴力打开一个盒子会出现两种情况： 拿到的钥匙是该暴力打开的盒子的钥匙。 拿着该钥匙打开另一个盒子，直到拿到第一次暴力打开的那个盒子的钥匙，而这实际上构成了一个循环。 根据离散数学的角度，这里的每种排列情况对应着一个置换，每一个循环对应一个轮换。 所以问题转化成 n！个n元置换中，有多少个置换可以分解为不超过k个不相交的轮换。由于100！非常大，所以问题不能单纯的暴力算出答案，而且需要高精度整数运算。 f[i][j]表示i元置换中可以分解为j个不相交轮换的个数。 f[n][1] + f[n][2] + … + f[n][k]即为问题所求。所以预处理求出所有状态，再将符合题目要求的结果求和。 状态转移的时候有两种情况： 前面i-1个元素组成j-1个轮换，第i个元素单独作为一个一元轮换。 前面i-1个元素组成j个轮换，第i个元素加入到前面的元素组成的某个轮换中，能加入的位置有i-1个。 假设现在有3个元素，这会将隔出4个位置 1□2□3□4 但是位置1和位置4所构成的循环是相同的。 状态转移方程 f[i][j] = f[i-1][j-1] + f[i-1][j]*(i-1)，特殊边界情况f[0][0]=1,f[0][j]=0。 关键代码12345678void preprocess()&#123; f[0][0] = 1; for(int i = 1; i &lt;= MAXN; i++)&#123; for(int j = 1;j &lt;= MAXN; j++)&#123; f[i][j] = f[i-1][j-1] + f[i-1][j]*(i-1); &#125; &#125;&#125;","categories":[],"tags":[{"name":"DP","slug":"DP","permalink":"http://yoursite.com/tags/DP/"},{"name":"置换轮换","slug":"置换轮换","permalink":"http://yoursite.com/tags/置换轮换/"}]},{"title":"[读薄系列]Merge Sort归并排序","slug":"Merge-Sort归并排序","date":"2017-03-10T02:36:07.000Z","updated":"2017-03-24T15:04:36.000Z","comments":true,"path":"2017/03/10/Merge-Sort归并排序/","link":"","permalink":"http://yoursite.com/2017/03/10/Merge-Sort归并排序/","excerpt":"","text":"排序基本思想分割将序列递归折半分割 合并回溯将之前被分割的两个序列合并后排序 排序过程原始序列 9 6 7 2 5 1 8 4 21234567891011121314151617分割9 6 7 2 | 5 1 8 4 29 6 | 7 2 5 1 | 8 4 29 | 6 7 | 2 5 | 1 8 | 4 29 | 6 7 | 2 5 | 1 8 4 | 2合并6 9 | 2 7 1 5 | 8 | 2 42 6 7 9 1 5 | 2 4 82 6 7 9 1 2 4 5 61 2 2 4 5 6 7 8 9 如何合并目标将包含n1个元素的数组L以及包含n2个元素的数组R，合并到数组A中 利用的条件两个数组均已排好序 合并过程每次从两个数组中取出一个元素进行比较，将小的那个元素放入数组A中，最后将各段中余下的部分直接复制到数组A中。为了简化合并代码的实现，可以在两个数组末尾分别插入一个大于所有元素的标记。在比较L，R元素的过程中，肯定会遇到元素与标记相比较，知道标记设置得足够大，且将比较次数限制在n1+n2之内，就可以既防止两个标记比较，又防止循环变量i，j分别超过n1，n2. 复杂度分析时间复杂度一般来说，n个数据大致会分为log2n层，由于每次合并的总复杂度是O(n)，因此归并排序整体的时间复杂度是O(nlog2n) 空间复杂度由于合并需要复制到另一个数组，故空间复杂度为O(n) 稳定性在合并两个已经排序的序列时，如果遇到相同的元素，只有保证前半部分数组优于后半部分数组，相同元素的顺序就不会颠倒了，因此归并排序属于稳定的排序算法 代码实现C++1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;using namespace std;#define MAX 500000#define SENTINEL 0x3f3f3f3f //标记int L[MAX/2],R[MAX/2+2];void merge(int A[], int n, int left,i nt mid, int right)&#123; int n1 = mid-left; int n2 = right-mid; for(int i = 0; i &lt; n1; i++) L[i] = A[left+i]; for(int i = 0; i &lt; n2; i++) R[i] = A[mid+i]; L[n1] = R[n2] = SENTINEL; int i = 0; int j = 0; for(int k = left; k &lt; right; k++)&#123; if(L[i] &lt;= R[i])&#123;//保证稳定性 A[k] = L[i++]; &#125; else&#123; A[k] = R[j++]; &#125; &#125;&#125;void mergeSort(int A[], int n, int left, int right)&#123; if(left+1 &lt; right)&#123; int mid = (left + right)/2; //分割 mergeSort(A, n, left, mid); mergeSort(A, n, mid, right); //合并 merge(A, n, left, mid, right); &#125;&#125;","categories":[],"tags":[{"name":"读薄系列","slug":"读薄系列","permalink":"http://yoursite.com/tags/读薄系列/"},{"name":"排序","slug":"排序","permalink":"http://yoursite.com/tags/排序/"},{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"}]},{"title":"未来火车站建设","slug":"未来火车站建设","date":"2017-03-09T15:08:21.000Z","updated":"2017-03-09T15:21:22.000Z","comments":true,"path":"2017/03/09/未来火车站建设/","link":"","permalink":"http://yoursite.com/2017/03/09/未来火车站建设/","excerpt":"","text":"未来的火车网络建设题意给定无向图，可以分为左、右两部,两图顶点数相等都为N（N&lt;=10），顶点都按1-N编号，开始时两图都为欧拉图（即图中每个点都为偶度点），后添加N条边，每条边都连接两图相同编号的顶点，这导致每个点都变为奇度点,即整个图不是欧拉图。图中所有的边都有权值，问如何复制现有的边使得整个图变为欧拉图（即所有顶点都为偶度点）且复制的边的总权值最小。 涉及知识点欧拉图通过图（无向图或有向图）中所有边且每边仅通过一次通路称为欧拉通路，相应的回路称为欧拉回路。具有欧拉回路的图称为欧拉图（Euler Graph），具有欧拉通路而无欧拉回路的图称为半欧拉图。 状态压缩状态压缩指状态用一种压缩的形式存储。一般采用一个二进制数表示状态，有时也用三进制或四进制数等。用二进制数表示状态最大的好处就是在决策转移时可以采用位运算，这样能极大提高算法效率。 最短路径问题解题思路 每条边最多只复制一次，对于奇偶性问题，同一条边复制两次对顶点的度数奇偶性的贡献相当于0。 连接左右两图的边很特殊，我们可以枚举选择当中的哪几条边，使得剩下的问题可以在左右两图内部各自解决而互不影响。 连接这些特殊边后，左右两图的顶点的奇偶性会发生变化，这时候问题就变为他们各自内部怎么使用最少的花费来到达顶点的这种奇偶状态。 由于顶点数不超过10个，所有可以用一个10位的二进制数表示每种奇偶状态，1为奇数，0为偶数。初始状态下，所有点都为奇数度，所有二进制位都为1。 如果选择连接(i， j)这条边， 那么可以让状态x和y之间相互转换，其中在x和y的二进制表示中只有第i位和第j位不一样，然后将状态抽象为点，上述转换的代价作为边权构建新图，再对新图求以初始状态对应顶点为源的单源最短路径。 关键代码12345678910111213141516171819202122232425262728293031323334353637void process()&#123; //求图g中各状态顶点间的最小变换花费 memset(G, -1, sizeof(G)); //初始化新矩阵G //枚举变换前状态i for(int i = 0; i &lt; n: i++) //n=(1&lt;&lt;N) for(int j = 1; j &lt; N; j++)&#123;//枚举复制边的端点j和k for(int k = 0; k &lt; N; k++)&#123; //改状态i第j和k位的奇偶性 //并记录变换花费为边jk的权 G[i][i^(1&lt;&lt;j)^(1&lt;&lt;k)] = g[j][k]; &#125; &#125; &#125; dijkstra(); //求出初始状态到其他任意状态的最小花费 for(int i = 0; i &lt; n; i++)&#123;//枚举每个状态 if(d[i] &lt; INF)&#123; f[i] += d[i]; //记录初始状态到状态i的最小变换花费 flag[i]++; //记录有几个图能够到达状态i &#125; &#125;&#125;void solve()&#123; //求解 … for(int i = 0; i &lt; n; i++)&#123;//枚举所有状态 if(flag[i] == 2)&#123; //是否两个图都能到达状态i int t = f[i]; //记录两个图到达i的变换花费 for(int j = 0; j &lt; N; j++)&#123;//枚举所有顶点 //判断i的第j个顶点是否是奇度点 if((i &amp; (1&lt;&lt;j)) &gt; 0)&#123; t += cross[j];//若是则复制两图j点间的这条边 &#125; &#125; ans = min(ans, t);//每次用两图间的边补全状态i,更新答案 &#125; &#125; …&#125;","categories":[],"tags":[{"name":"欧拉图","slug":"欧拉图","permalink":"http://yoursite.com/tags/欧拉图/"},{"name":"最短路径","slug":"最短路径","permalink":"http://yoursite.com/tags/最短路径/"},{"name":"状态压缩","slug":"状态压缩","permalink":"http://yoursite.com/tags/状态压缩/"}]},{"title":"[读薄系列]匈牙利算法","slug":"浅析匈牙利算法","date":"2017-03-08T14:23:14.000Z","updated":"2017-03-24T15:04:02.000Z","comments":true,"path":"2017/03/08/浅析匈牙利算法/","link":"","permalink":"http://yoursite.com/2017/03/08/浅析匈牙利算法/","excerpt":"","text":"二分图1.什么是二分图 将无向图G=的顶点集V分为两个子集V1和V2 G中的任意一条边的两个端点一个属于V1，另一个属于V2 2.如何判断一个图是二分图染色法：开始对任意一未染色的顶点染色，之后判断其相邻的顶点中，若未染色则将其染上和相邻顶点不同的颜色， 若已经染色且颜色和相邻顶点的颜色相同则说明不是二分图，若颜色不同则继续判断。 匈牙利算法-二分图的最大匹配1.匹配是什么在图论中，一个匹配（matching）是一个边的集合，其中任意两条边都没有公共顶点。所以最大匹配也就是拥有边数最多的那个集合。 2.交替路从一个未匹配的点出发，依次经过非匹配边，匹配边，非匹配边…形成的路径 3.增广路1.定义：从一个未匹配点出发，走交替路，如果途径另一个未匹配点，则这条交替路称为增广路2.特点： 非匹配边比匹配边多一条（因为起始和终止都是非匹配边） 起点和终点都是当前未匹配的点，其他的点都是已匹配的点 整条路径都没有重复的点 把增广路径上的所有第奇数条边加入到原匹配中去，并把增广路径中的所有第偶数条边从原匹配中删除（这个操作称为增广路径的取反），则新的匹配数就比原匹配数增加了1个 ####4.匈牙利算法的步骤情景假设：今晚有个舞会，四个男生，四个女生。男生可以邀请女生一起跳舞，并且男生开始前已经有心仪的对象（图中连线代表对该女生有意思） 将实线改成虚线，表示现在还没有人邀请成功。第一个男生有两个心仪的女生（芙蓉，赵四），按照顺序，他先邀请了第一个心仪女生（芙蓉），而该女生此时还没有接受其他人的邀请，此时邀请成功，并将该女生的搭档记录为该男生接下来轮到第二个男生，按照刚才的步骤成功邀请到翠花轮到第三个男生的时候出现了点小状况，他心仪的第一个对象已经被其他人邀请走了（翠花已经个俊杰搭档），此时第三个男生尝试去说服翠花接受他的邀请，翠花只能去问她当前的搭档俊杰，让他去找其他女生，但是俊杰心仪的对象只有一个，就是翠花，俊杰不同意，最后翠花只能拒绝了进进的邀请。 第三个男生尝试去邀请他的第二个心仪对象，发现该女生也被其他人邀请走了（芙蓉和朝钧搭档），按照老套路，芙蓉去跟朝钧协商，朝钧去邀请他第二个心仪的女生，发现该女生还没有搭档，因此朝钧答应了不再和芙蓉搭档而是和赵四搭档，此时芙蓉就可以和进进搭档了。更新搭档关系 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135//二维数组实现===============================================int ans;int k,n,m;int vis[MAXN];int link[MAXN];int Graph[MAXN][MAXN];bool FindPath(int u)&#123; for(int v=1;v&lt;=n;v++)&#123; if(Graph[u][v]==1&amp;&amp;vis[v]==0)&#123; vis[v]=1; if(link[v]==-1||FindPath(link[v]))&#123; link[v]=u; return true; &#125; &#125; &#125; return false;&#125;int hungary()&#123; memset(link,-1,sizeof(link)); for(int i=1;i&lt;=m;i++)&#123; memset(vis,0,sizeof(vis)); if(FindPath(i)) ans++; &#125; return ans;&#125;==================================================//邻接表优化int ans;int k,n,m;int vis[MAXN];int link[MAXN];vector&lt;int&gt; Graph[MAXN];void init()&#123; for(int i=0;i&lt;MAXN;i++) Graph[i].clear();&#125;bool FindPath(int u)&#123; for(int i=0;i&lt;Graph[u].size();i++)&#123; int v = Graph[u][i]; if(vis[v]==0)&#123; vis[v]=1; if(link[v]==-1||FindPath(link[v]))&#123; link[v]=u; return true; &#125; &#125; &#125; return false;&#125;int hungary()&#123; memset(link,-1,sizeof(link)); for(int i=1;i&lt;=m;i++)&#123; memset(vis,0,sizeof(vis)); if(FindPath(i)) ans++; &#125; return ans;&#125;","categories":[],"tags":[{"name":"读薄系列","slug":"读薄系列","permalink":"http://yoursite.com/tags/读薄系列/"},{"name":"匈牙利算法","slug":"匈牙利算法","permalink":"http://yoursite.com/tags/匈牙利算法/"},{"name":"二分图的最大匹配","slug":"二分图的最大匹配","permalink":"http://yoursite.com/tags/二分图的最大匹配/"}]},{"title":"关系数据理论","slug":"关系数据库-范式","date":"2017-02-24T14:16:17.000Z","updated":"2018-02-08T06:15:10.533Z","comments":true,"path":"2017/02/24/关系数据库-范式/","link":"","permalink":"http://yoursite.com/2017/02/24/关系数据库-范式/","excerpt":"","text":"一.问题的提出1.数据冗余导致的问题 冗余存储: 信息被重复存储 更新异常: 当重复信息的一个副本被修改时,要对所有副本进行同样的修改 插入异常: 只有当一些信息事先已经存放在数据库中时,另外一些信息才能存入数据库中 删除异常: 删除某些信息时可能丢失其他信息 2.模式分解导致的问题 有损分解: 通过连接分解后的较小关系不能完全还原被分解关系的所有实例 依赖丢失: 部分属性之间的依赖丢失 二.函数依赖的定义1.函数依赖 关系模式中属性之间存在的一种约束关系 设r(R)为关系模式,α⊆R,γ⊆R,对任意合法关系r及其中任意两个元祖ti和tj,i≠j,若ti[α]=tj[α],则ti[γ]=tj[γ],则称α函数确定γ,或γ函数依赖于α,记作α→γ简单来说就像函数y=f(x),x唯一确定y 2.平凡与非平凡函数依赖非平凡函数依赖:若α→γ,但γ不是α的真子集,则称α→γ是非平凡函数依赖平凡函数依赖:如γ是α的真子集,则称α→γ是平凡函数依赖 3.完全函数依赖和部分函数依赖 对于任意γ⊂α,γ→β都不成立,则称α→β是完全函数依赖,否则称部分函数依赖 部分函数依赖 4.传递函数依赖 若α→β,β→γ,则必存在函数依赖α→γ 三.范式 基于函数依赖理论,关系模式可分成第一范式(1NF),第二范式(2NF),第三范式(3NF)和Boyce-Codd范式 1.目标 减少数据冗余 消除异常（插入异常，更新异常，删除异常） 2.第一范式-码每个属性都不可再分 学号 姓名 系名 系主任 课名 分数 出现的问题 1.插入异常：当出现新的系时，无法单独地添加系名与系主任的数据到数据表中 2.更新异常：当某个学生转系时，需要将与该学生有关的记录一起修改 3.删除异常：当某个系的所有学生删除时，该系也不复存在（一个系所有学生都没有了，并不表示这个系就没有了） 4.数据冗余：每一名学生的学号、姓名、系名、系主任这些数据重复多次 3.第二范式-全部是码消除非主属性对码的部分函数依赖简单的说，是表中的属性必须完全依赖于全部主键，而不是部分主键 判断是否符合2NF的方法上表为例 确定码（学号，课名） 确定非主属性（系名，系主任，课名，分数） 查看是否存在非主属性对码的部分函数依赖{对于（学号，课名） → 姓名，有 学号 → 姓名，存在非主属性 姓名 对码（学号，课名）的部分函数依赖。对于（学号，课名） → 系名，有 学号 → 系名，存在非主属性 系名 对码（学号，课名）的部分函数依赖。对于（学号，课名） → 系主任，有学号 → 系主任，存在非主属性 对码（学号，课名）的部分函数依赖。} 所以该表只符合1NF,不符合2NF 模式分解将上述表拆分成两个表 学号 姓名 系名 码：（学号，姓名） 学号 姓名 系名 系主任 码：（学号）因为码只有一个属性，所以不可能存在非主属性对于码 的部分函数依赖，所以此表符合2NF的要求 出现的问题1.删除异常：删除某个系中所有的学生记录，该系的信息仍然全部丢失2.插入异常：无法插入一个尚无学生的新系的信息。因为学生表的码是学号，不能为空，所以此操作不被允许 4.第三范式-仅仅是码消除了非主属性对于码的传递函数依赖 参考作者：刘慰链接：https://www.zhihu.com/question/24696366/answer/29189700来源：知乎","categories":[],"tags":[{"name":"review","slug":"review","permalink":"http://yoursite.com/tags/review/"},{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/数据库/"}]},{"title":"LeetCode486. Predict the Winner","slug":"LeetCode486-Predict-the-Winner","date":"2017-02-23T15:05:05.000Z","updated":"2017-02-23T15:23:05.000Z","comments":true,"path":"2017/02/23/LeetCode486-Predict-the-Winner/","link":"","permalink":"http://yoursite.com/2017/02/23/LeetCode486-Predict-the-Winner/","excerpt":"","text":"题目传送门 题意两个人交替从一个数组两端获取一个数字，每次每个人只能获取一个，最终获取的数字之和最大的获胜，问第一个人能否获胜？ 分析最优子结构：dp[i][j]维护从i到j获取的所有数字之和的最大值，则dp[i+1][j]表示第二个人能够在i-1到j之间获取的所有数字之和的最大值，dp[i][j-1]表示第二个人能够在i到j-1之间获取的所有数字之和的最大值。 sum[i][j]维护 i 到 j 所有数字之和，因为两个人都想赢，即每个人都取最优解，所以sum[i+1][j] - dp[i+1][j]表示第一个人取第i个元素以后，能够在 i+1 到 j 之间获取子数组之和的最大值，sum[i][j-1] - dp[i][j-1]标识第一个人取第j个元素以后，能够在 i 到 j-1 之间获取子数组之和的最大值。 状态转移方程：dp[i][j] = max{ nums[i]+sum[i+1][j]-dp[i+1][j], nums[j]+sum[i][j-1]-dp[i][j-1]}当i == j时，只有一种选择，dp[i][j] = nums[i]当i == j-1 时，只有两种选择，dp[i][j] = max(nums[i], nums[j]) 代码1234567891011121314151617181920212223242526public class Solution &#123; public boolean PredictTheWinner(int[] nums) &#123; int n = nums.length; int[][] dp = new int[n][n]; int[] presum = new int[n+1]; for(int i = 0;i &lt; n;i++) &#123; presum[i+1] = presum[i]+nums[i]; &#125; for(int len = 1;len &lt;= n;len++)//长度为n的最优解需要用到长度为n-1的最优解 for(int l = 0;l + len - 1 &lt; n;l++)&#123; int r = l + len - 1; if(l==r)&#123; dp[l][r] = nums[l]; &#125; else if(l == r-1)&#123; dp[l][r] = Math.max(nums[l],nums[r]); &#125; else&#123; dp[l][r] = Math.max(nums[l]+presum[r+1]-presum[l+1]-dp[l+1][r], nums[r]+presum[r]-presum[l]-dp[l][r-1]); &#125; &#125; return dp[0][n-1]*2&gt;=presum[n]; &#125;&#125;","categories":[],"tags":[{"name":"DP","slug":"DP","permalink":"http://yoursite.com/tags/DP/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"[Codeforces731B]Coupons and Discounts","slug":"Codeforces731B-Coupons-and-Discounts","date":"2017-02-17T05:46:36.000Z","updated":"2017-02-17T05:57:49.000Z","comments":true,"path":"2017/02/17/Codeforces731B-Coupons-and-Discounts/","link":"","permalink":"http://yoursite.com/2017/02/17/Codeforces731B-Coupons-and-Discounts/","excerpt":"","text":"题目传送门 题意n个数字，两种操作 相邻两个数加1 一个数加2 问能不能根据这些操作构成这些数字 分析贪心一下，能放2就放2，所以偶数转成2，奇数转成1，0还是0遍历一遍 如果当前是1，则下一个数减1，再判断下一个数是否小于0 如果当前是2，直接减2 代码123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define MAXN 200005using namespace std;int num[MAXN];int main() &#123; int n; int flag; while (cin &gt;&gt; n) &#123; flag = 0; for (int i = 1; i &lt;= n; i++) &#123; scanf(\"%d\", &amp;num[i]); if (num[i] != 0) &#123; if (num[i] % 2) num[i] = 1; else num[i] = 2; &#125; &#125; for (int i = 1; i &lt; n; i++) &#123; if (num[i] == 1) &#123; num[i]--; num[i + 1]--; if (num[i + 1] &lt; 0) &#123; flag = 1; break; &#125; &#125; else if (num[i] == 2) &#123; num[i] -= 2; &#125; &#125; if (num[n] == 1) flag = 1; if (flag) cout &lt;&lt; \"NO\" &lt;&lt; endl; else cout &lt;&lt; \"YES\" &lt;&lt; endl; &#125; return 0;&#125;","categories":[],"tags":[{"name":"CodeForces","slug":"CodeForces","permalink":"http://yoursite.com/tags/CodeForces/"}]},{"title":"[读薄系列]KMP算法(看毛片？)","slug":"浅析看毛片算法-KMP","date":"2017-02-09T06:13:33.000Z","updated":"2017-03-24T15:03:43.000Z","comments":true,"path":"2017/02/09/浅析看毛片算法-KMP/","link":"","permalink":"http://yoursite.com/2017/02/09/浅析看毛片算法-KMP/","excerpt":"","text":"1.什么是“看毛片算法”？一种字符串查找算法，在一个主文本字符串S内查找一个词W的出现位置。其实说“看毛片算法”显得不尊重老前辈WIKI解释 2.之前是如何暴力查找的？ 从两个串的第一个元素开始比较，直到有一个字符不相同 模式串向后移一位，继续比较 很黄很暴力，当空格与D不匹配时，你其实比较过前面六个字符是”ABCDAB”。每次都往后移一位就没有利用到这个信息了。 3.KMP如何改进的？思想设法利用这个已知信息，不要把”搜索位置”移回已经比较过的位置，继续把它向后移，这样就提高了效率。 部分匹配表“前缀”和”后缀”的最长的共有元素的长度以模式串ABCDABD为例 上面那个例子，查表可知最后一个匹配的字符‘B’对应的值为2，意思为前面有一段长度为2的字符串和后面一个段长度为2的字符串匹配，既“AB”==“AB”，所以这时候可以直接跳到第二个AB继续匹配。所以得出公式 移动位数 = 已匹配的字符数 - 最后一个匹配字符对应的部分匹配值 第一个”AB”向后移动4位（字符串长度[6]-部分匹配值[2]），就可以来到第二个”AB”的位置。 以此类推，因为空格与Ｃ不匹配，搜索词还要继续往后移。这时，已匹配的字符数为2（”AB”），对应的”部分匹配值”为0。所以，移动位数 = 2 - 0，结果为 2，于是将搜索词向后移2位。特殊情况第一个字符不匹配时，公式不适用，直接往后移一位。 next数组相当于部分匹配表向右移一位，第一位-1补上 移动位数 = 失配字符所在位置 - 失配字符对应的next值 next数组和部分匹配表得出来的移动位数是一样的证明：从0开始计数，失配字符所在位置= =已匹配的字符数。next数组是由部分匹配表向右移一位构造的，所以失配字符对应的next值= =最后一个匹配字符对应的部分匹配值 递推算出next数组 若p[k] == p[j]，则 next[ j + 1 ] = next [j] + 1 = k + 1； 若p[k] ≠ p[j]，递归前缀索引k = next[k]，直到p[k’] == p[j],从而 next [j + 1] = k’ + 1 = next [k’] + 1四个蓝色的区域表示相同的字符串 12345678910111213141516void GetNext(char* p,int next[])&#123; int pLen = strlen(p); next[0] = -1; int k = -1; int j = 0; while (j &lt; pLen - 1)&#123; //p[k]表示前缀，p[j]表示后缀 if (k == -1 || p[j] == p[k])&#123; ++k; ++j; next[j] = k; &#125; else k = next[k]; &#125; &#125; 基于next数组进行模式匹配123456789101112131415161718192021int KmpSearch(char* s, char* p)&#123;//p是模式串 int i = 0; int j = 0; int sLen = strlen(s); int pLen = strlen(p); while (i &lt; sLen &amp;&amp; j &lt; pLen)&#123; //①j = -1表示第一个字符不相同当 if (j == -1 || s[i] == p[j])&#123; i++; j++; &#125; else&#123; //递归前缀索引 j = next[j]; &#125; &#125; if (j == pLen) return i - j;//返回出现的位置 else return -1;&#125; 参考资料阮一峰《字符串匹配的KMP算法》v_JULY_v《从头到尾彻底理解KMP》","categories":[],"tags":[{"name":"读薄系列","slug":"读薄系列","permalink":"http://yoursite.com/tags/读薄系列/"},{"name":"KMP","slug":"KMP","permalink":"http://yoursite.com/tags/KMP/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/tags/Algorithm/"}]},{"title":"LeetCode343.Integer Break","slug":"LeetCode343-Integer-Break","date":"2017-02-04T11:30:01.000Z","updated":"2017-02-04T11:59:44.000Z","comments":true,"path":"2017/02/04/LeetCode343-Integer-Break/","link":"","permalink":"http://yoursite.com/2017/02/04/LeetCode343-Integer-Break/","excerpt":"","text":"题意给一个n(2≤n≤58),求相加等于n且乘积最大的一组整数的积。 思路A. DP解法(O(N))dp[i]维护数字i拆分后最大的积，由于有些数字不拆分比拆分后的积大，例如3所以状态转移方程为 dp[i] = max{ max(dp[i-k],i-k) * max(dp[k],k) }(1≤k&lt;i) B. 数学解法(O(logN)) 平方平均数: 算术平均数: 几何平均数: 调和平均数: 调和平均数 ≤ 几何平均数 ≤ 算术平均数 ≤ 平方平均数 所以把n拆分成几个相等的数时它们的积最大。假设每一个数为x,则一共有n/x个数。他们的积f(x) = xn/x,现在问题变为x为何值时，函数取得最大值。求导！f’(x) = (n/x2) x(n/x) (1-lnx),得x为e时，取得极大值。e = 2.71828…,所以取3时，所得的积最大。 代码A12345678910public class Solution &#123; public int integerBreak(int n) &#123; int[] dp = new int[n+1]; dp[1] = 1; for(int i = 1;i &lt;= n;i++) for (int k = 1; k &lt; i; k++) dp[i] = Math.max(dp[i], Math.max(dp[i - k],i-k) * Math.max(k,dp[k])); return dp[n]; &#125;&#125; B12345678910111213public class Solution &#123; public int integerBreak(int n) &#123; if(n==2) return 1; if(n==3) return 2; int product = 1; while(n&gt;4)&#123; product*=3; n-=3; &#125; product*=n; return product; &#125;&#125;","categories":[],"tags":[{"name":"Math","slug":"Math","permalink":"http://yoursite.com/tags/Math/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"[Codeforces761B]Dasha and friends","slug":"Codeforces761B-Dasha-and-friends","date":"2017-02-01T08:15:31.000Z","updated":"2017-02-01T10:50:03.000Z","comments":true,"path":"2017/02/01/Codeforces761B-Dasha-and-friends/","link":"","permalink":"http://yoursite.com/2017/02/01/Codeforces761B-Dasha-and-friends/","excerpt":"","text":"题目传送门 题意两个人逆时针绕长度为L的圈跑，并在n个点停留。由于起点不一样，所以到达这n个点的距离不一样，现在给定这两个人先后到达这n个点的距离，判断两人是否绕同一个圈跑。Consider an example. Let L = 8, blue points are barriers, and green points are Kefa’s start (A) and Sasha’s start (B). Then Kefa writes down the sequence[2, 4, 6], and Sasha writes down [1, 5, 7]. 思路虽然起点不一样，但如果是同一个圈的话，这n个点的相对位置是一样的，既任意两点的最短距离一致。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;set&gt;#define READ(x) scanf(\"%d\",&amp;x)#define READLL(x) scanf(\"%lld\",&amp;x)#define LL long long#define MAXNusing namespace std;int dis1[5000];int dis2[5000];int cnt1,cnt2;int n;int L;int num[60];int main()&#123; int flag; int q; while(cin&gt;&gt;n&gt;&gt;L)&#123; cnt1 = cnt2 = 0; flag = 0; for(int i = 1;i &lt;= n;i++) READ(num[i]); for(int i = 1;i &lt;= n;i++)&#123; for(int j = i+1;j &lt;= n;j++)&#123; q = min(abs(num[i]-num[j]),L-abs(num[i]-num[j])); dis1[++cnt1]=q; &#125; &#125; for(int i = 1;i &lt;= n;i++) READ(num[i]); for(int i = 1;i &lt;= n;i++)&#123; for(int j = i+1;j &lt;= n;j++)&#123; q = min(abs(num[i]-num[j]),L-abs(num[i]-num[j])); dis2[++cnt2]=q; &#125; &#125; sort(dis1,dis1+cnt1+1); sort(dis2,dis2+cnt2+1); for (int i = 1;i&lt;=cnt1;i++)&#123; if(dis1[i]!=dis2[i])&#123; flag = 1; break; &#125; &#125; if(flag) cout&lt;&lt;\"NO\"&lt;&lt;endl; else cout&lt;&lt;\"YES\"&lt;&lt;endl; &#125; return 0;&#125;","categories":[],"tags":[{"name":"CodeForces","slug":"CodeForces","permalink":"http://yoursite.com/tags/CodeForces/"}]},{"title":"LeetCode419. Battleships in a Board","slug":"LeetCode419-Battleships-in-a-Board","date":"2017-02-01T06:37:30.000Z","updated":"2017-02-01T06:50:49.000Z","comments":true,"path":"2017/02/01/LeetCode419-Battleships-in-a-Board/","link":"","permalink":"http://yoursite.com/2017/02/01/LeetCode419-Battleships-in-a-Board/","excerpt":"","text":"题意给一个二维地图，统计图中战舰的数量，图中“X”表示战舰，“.”表示空地。 给的图一定是一个合法的地图 战舰的长度不固定，可以是1XN（1行N列）或者NX1（N行1列） 两个战舰间在水平或者垂直方向上至少有一个间隔 要求不申请空间 合法地图 X..X…X…X 两艘战舰 不合法地图 …XXXXX…X 思路给一个合法地图，不需要判断合不合法！给一个合法地图，不需要判断合不合法！给一个合法地图，不需要判断合不合法！ 因为船的方向只有垂直和水平，所以假定船头是朝上或者朝左，既只要统计船头数量即可。若一个点是船头，则该点是“X”，且左边为“.”或者上边是“.” 代码12345678910111213public class Solution &#123; public int countBattleships(char[][] board) &#123; int ans = 0; for(int i = 0;i&lt;board.length;i++) for(int j = 0;j&lt;board[i].length;j++)&#123; if(board[i][j]=='X' &amp;&amp; (i==0||board[i-1][j]=='.') &amp;&amp; (j==0||board[i][j-1]=='.')) ans++; &#125; return ans; &#125;&#125;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"LeetCode238. Product of Array Except Self","slug":"LeetCode238-Product-of-Array-Except-Self","date":"2017-01-31T09:46:51.000Z","updated":"2017-01-31T15:22:50.000Z","comments":true,"path":"2017/01/31/LeetCode238-Product-of-Array-Except-Self/","link":"","permalink":"http://yoursite.com/2017/01/31/LeetCode238-Product-of-Array-Except-Self/","excerpt":"","text":"题意给一个数组A，生成一个数组B，B[i] = A[0] x A[1] x..x A[i-1] x A[i+1] x..x A[n]时间复杂度O(N)，不能使用除法 思路仔细看一下，其实每次计算B[i]就是前面i-1个元素相乘，乘上后面i+1个元素相乘。所以只要预处理前缀积和后缀积即可。 代码 版本1 O(N)，S(N) 123456789101112131415161718public class Solution &#123; public int[] productExceptSelf(int[] nums) &#123; int[] pre = new int[nums.length];//前缀积 int[] sub = new int[nums.length];//后缀积 int[] ans = new int[nums.length]; pre[0] = nums[0]; sub[nums.length-1]=nums[nums.length-1]; for(int i = 1;i&lt;nums.length;i++) pre[i] = pre[i-1]*nums[i]; for(int i = nums.length-2;i&gt;=0;i--) sub[i] = sub[i+1]*nums[i]; ans[0] = sub[1]; ans[nums.length-1]=pre[nums.length-2]; for(int i = 1;i&lt;nums.length-1;i++) ans[i] = pre[i-1]*sub[i+1];//前i-1个的积*后i+1个的积 return ans; &#125;&#125; 版本2 O(N),S(1) 123456789101112131415public class Solution &#123; public int[] productExceptSelf(int[] nums) &#123; int n = nums.length; int[] res = new int[n]; res[0] = 1; for (int i = 1; i &lt; n; i++) res[i] = res[i - 1] * nums[i - 1];//res[i]保存的是前i-1个数的积 int right = 1; for (int i = n - 1; i &gt;= 0; i--) &#123; res[i] *= right;//当前的right值为后i+1个数的积 right *= nums[i];//更新为后i个数的积 &#125; return res; &#125;&#125;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Happy New Year 2017","slug":"Happy-New-Year-2017","date":"2017-01-27T11:45:31.000Z","updated":"2017-01-27T11:57:31.000Z","comments":true,"path":"2017/01/27/Happy-New-Year-2017/","link":"","permalink":"http://yoursite.com/2017/01/27/Happy-New-Year-2017/","excerpt":"","text":"今天除夕夜，写下今年的愿望吧~ 家人身体健康 蓝桥杯省赛拿个一等去北京旅游 ACM省赛拿个铜牌结束自己的生涯 找个女朋友？ 暑假找个满意的实习 去个没去过的地旅游 体重控制在140-150 早睡早起 暂时就这些吧出去耍了⁄(⁄ ⁄•⁄ω⁄•⁄ ⁄)⁄","categories":[],"tags":[{"name":"杂","slug":"杂","permalink":"http://yoursite.com/tags/杂/"}]},{"title":"CodeForcesEdu17[A.k-th divisor]","slug":"CodeForcesEdu17A-k-th-divisor","date":"2017-01-27T08:01:20.000Z","updated":"2017-02-04T12:00:28.000Z","comments":true,"path":"2017/01/27/CodeForcesEdu17A-k-th-divisor/","link":"","permalink":"http://yoursite.com/2017/01/27/CodeForcesEdu17A-k-th-divisor/","excerpt":"","text":"传送门 题意求一个数n（1≤n≤1015）的第k（1≤n≤109）个因子. 思路一个数的因子都是成对出现的，所以只要遍历$\\sqrt{n}$,用两个数组保存因子div1数组是升序div2数组是降序 注意 注意判断一个下平方数，因为会使div1的最后一个元素和div2的最后一个元素重复 数字较大，判断平方数的时候注意精度损失 代码12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;cmath&gt;#define MAXN 100005#define LL long longusing namespace std;LL div1[MAXN];LL div2[MAXN];int cnt;LL n;int k;int flag;int main()&#123; while(scanf(\"%lld %d\",&amp;n,&amp;k)!=EOF)&#123; cnt = 0; flag = 0; for(int i = 1;i&lt;=sqrt((double)n);i++)&#123; if(n%i==0)&#123; div1[++cnt]=i; div2[cnt]=n/i; &#125; &#125; if((LL)sqrt(n)*(LL)sqrt(n)==n)//判断是不是平方数 flag = 1; if(flag &amp;&amp; k&gt;2*cnt-1)&#123; cout &lt;&lt; \"-1\" &lt;&lt; endl; continue; &#125; if(k&lt;=cnt) cout&lt;&lt;div1[k]&lt;&lt;endl; else if(k&lt;=2*cnt &amp;&amp; !flag) cout&lt;&lt;div2[cnt-(k-cnt)+1]&lt;&lt;endl; else if(k&lt;=2*cnt &amp;&amp; flag) cout&lt;&lt;div2[cnt-(k-cnt)]&lt;&lt;endl; else cout&lt;&lt;\"-1\"&lt;&lt;endl; &#125;&#125;//99999999994190 9//241656799","categories":[],"tags":[{"name":"CodeForces","slug":"CodeForces","permalink":"http://yoursite.com/tags/CodeForces/"},{"name":"Math","slug":"Math","permalink":"http://yoursite.com/tags/Math/"}]},{"title":"LeetCode413. Arithmetic Slices","slug":"LeetCode413-Arithmetic-Slices","date":"2017-01-26T13:27:01.000Z","updated":"2017-01-26T13:59:31.000Z","comments":true,"path":"2017/01/26/LeetCode413-Arithmetic-Slices/","link":"","permalink":"http://yoursite.com/2017/01/26/LeetCode413-Arithmetic-Slices/","excerpt":"","text":"题意给定一个数组，求满足连续的相邻的元素的差值一样的子序列（至少3个元素）有多少个？[1,2,3,4]-&gt;[1,2,3],[2,3,4],[1,2,3,4] 3个 思路 预处理数组相邻元素的差值 遍历找差值一样的片段 例如数组A为[1,2,3,4,6,7,8]预处理后得到数组[1,1,1,2,1,1]找到两个值相同的片段[1,1,1],[1,1]，长度分别为3和2长度为n的片段代表有n+1个连续的元素差值相同，则长度大于等于3的子序列有∑(n-1)种 代码第一次写的版本缺陷：修改了原数组12345678910111213141516public class Solution &#123; public int numberOfArithmeticSlices(int[] A) &#123; int ans = 0; int cnt = 1; for(int i = 0;i &lt; A.length-1;i++)&#123; A[i]=A[i+1]-A[i]; if(i!=0 &amp;&amp; A[i]==A[i-1]) cnt++; else &#123; if(cnt&gt;=2) ans+=(cnt*(cnt-1))/2; cnt = 1; &#125; &#125; if(cnt&gt;=2) ans+=(cnt*(cnt-1))/2; return ans; &#125;&#125; 优化版本1234567891011public int numberOfArithmeticSlices(int[] A) &#123; int curr = 0, sum = 0; for (int i=2; i&lt;A.length; i++) if (A[i]-A[i-1] == A[i-1]-A[i-2]) &#123; curr += 1; sum += curr; &#125; else &#123; curr = 0; &#125; return sum;&#125;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"LeetCode338.Counting Bits","slug":"LeetCode338-Counting-Bits","date":"2017-01-25T13:31:42.000Z","updated":"2017-01-26T13:59:52.000Z","comments":true,"path":"2017/01/25/LeetCode338-Counting-Bits/","link":"","permalink":"http://yoursite.com/2017/01/25/LeetCode338-Counting-Bits/","excerpt":"","text":"题意O(n)复杂度计算0到num每个数字二进制表示中1的个数。 思路 找出最优子结构：当计算二进制为n位的数字时，n-1位的所有情况已经计算过了 推出状态转移方程：ans[i] = ans[i&gt;&gt;1]+(i&amp;1) 代码12345678public class Solution &#123; public int[] countBits(int num) &#123; int[] ans = new int[num+1]; for(int i = 1;i &lt;= num;i++) ans[i] = ans[i&gt;&gt;1]+(i&amp;1); return ans; &#125;&#125;","categories":[],"tags":[{"name":"DP","slug":"DP","permalink":"http://yoursite.com/tags/DP/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"LeetCode232 两个栈实现队列","slug":"LeetCode232-两个栈实现队列","date":"2017-01-23T08:10:25.000Z","updated":"2017-01-26T14:00:08.000Z","comments":true,"path":"2017/01/23/LeetCode232-两个栈实现队列/","link":"","permalink":"http://yoursite.com/2017/01/23/LeetCode232-两个栈实现队列/","excerpt":"","text":"题意：利用栈实现队列的功能 入队 出队 返回队头元素 判空 思路：利用两个栈 入队：直接放入s1 出队：如果s2为空，则将s1中的元素按弹出的顺序全部压入s2，根据栈的特性，s2中的栈顶元素就是“队头”元素了。如果s2不为空，则s2也是当前“队列”的队头 返回队头：如果s2为空，则s1的第一个元素为”队头“，不为空则s2的最后一个元素为”队头“ 判空：如果s1和s2同时为空，则为空 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class MyQueue &#123; private Stack s1; private Stack s2; /** Initialize your data structure here. */ public MyQueue() &#123; s1 = new Stack(); s2 = new Stack(); &#125; /** Push element x to the back of queue. */ public void push(int x) &#123; s1.push(x); &#125; /** Removes the element from in front of queue and returns that element. */ public int pop() &#123; if(s2.empty())&#123; while(!s1.empty()) s2.push(s1.pop()); &#125; return (int)s2.pop(); &#125; /** Get the front element. */ public int peek() &#123; if(s2.empty()) return (int)s1.firstElement(); return (int)s2.lastElement(); &#125; /** Returns whether the queue is empty. */ public boolean empty() &#123; if(s1.empty() &amp;&amp; s2.empty()) return true; return false; &#125;&#125;/** * Your MyQueue object will be instantiated and called as such: * MyQueue obj = new MyQueue(); * obj.push(x); * int param_2 = obj.pop(); * int param_3 = obj.peek(); * boolean param_4 = obj.empty(); */","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"}]},{"title":"MVC架构初涉","slug":"MVC架构初涉","date":"2017-01-18T08:27:08.000Z","updated":"2017-01-26T14:00:21.000Z","comments":true,"path":"2017/01/18/MVC架构初涉/","link":"","permalink":"http://yoursite.com/2017/01/18/MVC架构初涉/","excerpt":"","text":"三层模型首先对用户来说，浏览器就是表示层，它主要是与用户交互的页面，根据用户的输入与事件，处理并显示返回的特定数据。我们知道数据是一切应用程序的基础，如果没有数据，那么没有任何意义，所以 Server 端必须要一个强大的数据库来存储所有用户交互产生的数据，而对这些数据的处理，包括增、删、改、查就属于数据访问层。那么连接表示层与数据访问层的就是业务逻辑层，这包括后端程序中模型设计、验证、业务规则、各种计算等。 结构 模型 MODEL（数据保存）应用程序的数据和用于控制，访问，修改这些数据的业务规则 模型发生改变时，它会通知视图，并为视图提供查询模型相关状态的能力 为控制器提供访问封装在模型内部的应用程序功能的能力 视图 VIEW（用户界面）用来组织模型的内容，从模型那里获得数据，并指定这些数据如何表现。当模型变化时，视图负责维持数据表现的一致性 视图同时将用户的要求告知控制器 控制器 CONTROLLER（业务逻辑）定义了应用程序的行为 为来自视图的用户要求进行解释，并把这些要求映射成相应的行为，这些行为由模型负责实现 根据用户请求和模型行为的结果，控制器选择一个视图作为用户请求的应答 处理过程1.直接通过controller接受指令 控制器接收用户请求，并决定调用哪个模型来进行处理 模型根据用户请求进行相应的业务逻辑处理，并返回数据 控制器调用相应的视图格式化模型返回的数据，并通过视图呈现给用户 2.通过 View 接受指令，传递给 Controller3.更灵活的方式以 Backbone.js 为例 用户可以向 View 发送指令（DOM 事件），再由 View 直接要求 Model 改变状态。 用户也可以直接向 Controller 发送指令（改变 URL 触发 hashChange 事件），再由 Controller 发送给 View。 Controller 非常薄，只起到路由的作用，而 View 非常厚，业务逻辑都部署在 View。所以，Backbone 索性取消了 Controller，只保留一个 Router（路由器） 。 优点 可重用性：多个视图能共享一个模型 良好的松耦合：三个模块相互独立 提高应用程序的灵活性和可配置性","categories":[],"tags":[{"name":"MVC","slug":"MVC","permalink":"http://yoursite.com/tags/MVC/"}]},{"title":"Mysql安装(Mac)","slug":"Mysql安装-Mac","date":"2017-01-16T13:16:56.000Z","updated":"2017-01-26T14:00:28.000Z","comments":true,"path":"2017/01/16/Mysql安装-Mac/","link":"","permalink":"http://yoursite.com/2017/01/16/Mysql安装-Mac/","excerpt":"","text":"1.官网下载最新的社区版地址：http://dev.mysql.com/downloads/mysql/dmg格式是最方便的 2.安装双击mysql-5.7.17-osx10.12-x86_64.dmg文件，加载镜像双击mysql-5.7.17-osx10.12-x86_64.pkg，开始安装一路下一步，即可安装成功注意：安装完成之后会弹出一个对话框，告诉我们生成了一个root账户的临时密码。 4.配置修改.bash文件：为Path路径附加MySQL的bin目录PATH=”$PATH”:/usr/local/mysql/bin 5.启动系统偏好设置-&gt;mysql-&gt;start Mysql Server 6.修改密码 mysql -u root -puse mysqlset password for ‘root’@’localhost’=password(‘新密码’);","categories":[],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"}]},{"title":"LeetCode(Easy)-17/1/13","slug":"LeetCode-17-1-13","date":"2017-01-13T12:28:20.000Z","updated":"2017-01-26T14:00:00.000Z","comments":true,"path":"2017/01/13/LeetCode-17-1-13/","link":"","permalink":"http://yoursite.com/2017/01/13/LeetCode-17-1-13/","excerpt":"","text":"409. Longest Palindrome 题意：给定一些字符，问能构成的最长的回文串长度是多少 思路：每两个相同的字符就可以增加回文串2长度，如果有单个字符，则可以将其放在回文串的中间 代码 1234567891011121314151617public int longestPalindrome(String s) &#123; int ans = 0; char c; Set set = new HashSet(); for(int i = 0;i &lt; s.length();i++)&#123; c = s.charAt(i); if(!set.contains(c))&#123; set.add(c); &#125; else &#123;//有两个相同的c set.remove(c); ans += 2; &#125; &#125; if(set.size()!=0) ans++;//有单个字符 return ans;&#125; 217. Contains Duplicate 题意：判断数组中的每个数字是不是只出现一次 思路：利用的set的性质就可以了，判断一下set的大小是不是等于数组长度 代码 123456public boolean containsDuplicate(int[] nums) &#123; Set s = new HashSet(); for(int i = 0;i &lt; nums.length;i++) s.add(nums[i]); return s.size()!=nums.length;&#125; 231. Power of Two 题意：判断一个数是否是2的乘方 思路： 利用n&amp;(n-1)==0,例如00100 &amp; 00011 = 00000 利用对数函数的换底公式2^x=N-&gt;log2(N)=X-&gt;log10(N)/log10(2)=X,所以只要判X是不是整数就行了 代码 123456public boolean isPowerOfTwo(int n) &#123; // if(n&lt;=0) // return false; // return (n&amp;(n-1))==0; return (Math.log10(n)/Math.log10(2))%1==0; &#125; 326. Power of Three 题意：不使用循环或递归判断一个数是不是3的乘方 思路： 预处理int范围内最大的3的乘方 利用对数函数的换底公式 代码 123456public boolean isPowerOfThree(int n) &#123; //1.先求出3^19 //return n &gt; 0 &amp;&amp; (1162261467 % n == 0); //2.log10(n)/log10(3)是不是整数 return (Math.log10(n) / Math.log10(3)) % 1 == 0; &#125; 342. Power of Four 题意：不使用循环或递归判断一个数是不是4的乘方 思路： 对数函数换底公式 位运算判断大于0，是2的倍数，且1只在偶数位上，0x55555555=01010101010101010101010101010101 代码 1234public boolean isPowerOfFour(int num) &#123; //return (Math.log10(num)/Math.log10(4))%1==0; return num &gt; 0 &amp;&amp; (num&amp;(num-1)) == 0 &amp;&amp; (num &amp; 0x55555555) != 0;&#125; 191. Number of 1 Bits 题意：求一个数的二进制数1的位数 思路：通过移位，每次判断最后一个位是不是1，&gt;&gt;&gt;无符号右移，即高位补0 代码 12345678910public int hammingWeight(int n) &#123; System.out.println(Integer.toBinaryString(n)); int ans = 0; while(n!=0) &#123; ans += (n &amp; 1); n &gt;&gt;&gt;= 1; System.out.println(Integer.toBinaryString(n)); &#125; return ans;&#125; Integer.bitCount源码 12345678public static int bitCount(int i) &#123; i = i - ((i &gt;&gt;&gt; 1) &amp; 0x55555555); i = (i &amp; 0x33333333) + ((i &gt;&gt;&gt; 2) &amp; 0x33333333); i = (i + (i &gt;&gt;&gt; 4)) &amp; 0x0f0f0f0f; i = i + (i &gt;&gt;&gt; 8); i = i + (i &gt;&gt;&gt; 16); return i &amp; 0x3f;&#125;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"[Codeforces740C]Alyona and mex","slug":"Codeforces740C-Alyona-and-mex","date":"2017-01-12T13:02:24.000Z","updated":"2017-01-12T13:08:02.000Z","comments":true,"path":"2017/01/12/Codeforces740C-Alyona-and-mex/","link":"","permalink":"http://yoursite.com/2017/01/12/Codeforces740C-Alyona-and-mex/","excerpt":"","text":"传送门 题意给定长度为n的数组，m个区间，要求构造一个数组（元素大于等于0），求出mex的最小值。mex：区间里没有出现的最小元素（大于等于0）并使mex尽量大 思路一个重要的特点： 一个数组的mex取决于给定区间的长度，数组中最小的mex等于给定区间的最短长度。证明：要尽量使mex尽量大，最短区间的数字只能从0开始递增，这时mex的值就为区间的长度 因此原数组只要照[0,1,…,mex-1]的规则从左至右构造下去即可，这样就使得给定的每组区间的mex相等且mex尽量大 代码12345678910111213141516#include &lt;iostream&gt;#include &lt;algorithm&gt;#define INF 0x3f3f3f3fusing namespace std;int n, m, l, r, k = INF;int main() &#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; l &gt;&gt; r; k = min(r - l + 1, k); &#125; cout &lt;&lt; k &lt;&lt; endl; for (int i = 0; i &lt; n; i++) cout &lt;&lt; i % k &lt;&lt; \" \"; return 0;&#125;","categories":[],"tags":[{"name":"CodeForces","slug":"CodeForces","permalink":"http://yoursite.com/tags/CodeForces/"}]},{"title":"LeetCode(Easy)-17/1/11","slug":"leetcode-17-1-11","date":"2017-01-12T11:59:31.000Z","updated":"2017-01-12T13:11:41.000Z","comments":true,"path":"2017/01/12/leetcode-17-1-11/","link":"","permalink":"http://yoursite.com/2017/01/12/leetcode-17-1-11/","excerpt":"","text":"476. Number Complement 题意：二进制翻转 思路： 暴力将每一位为0的对应的2的乘方加起来 ~num &amp; ((Integer.highestOneBit(num) &lt;&lt; 1) - 1);highestOneBit(num)：获取长整数二进制最高位1的索引 代码123public int findComplement(int num) &#123; return ~num &amp; ((Integer.highestOneBit(num) &lt;&lt; 1) - 1);&#125; 283. Move Zeroes 题意：在不开新数组的情况下将一个数组的0移到最后 思路：没什么好说的( ⊙ o ⊙ ) 代码123456789public void moveZeroes(int[] nums) &#123; int index = 0; for(int i = 0;i&lt;nums.length;i++)&#123; if(nums[i] != 0) nums[index++]=nums[i]; &#125; for(;index&lt;nums.length;index++) nums[index] = 0;&#125; 392. Is Subsequence 题意：判断一个字符串是不是另一个字符串的子序列 思路：暴力判断字符串的每个字符 代码1234567891011public boolean isSubsequence(String s, String t) &#123; int i = 0; for(int j = 0;i&lt;s.length() &amp;&amp; j&lt;t.length();j++)&#123; if(s.charAt(i)==t.charAt(j)) i++; &#125; if(i!=s.length()) return false; else return true;&#125; 383. Ransom Note 题意：判断一个字符串中的字符能不能构成另一个字符串的部分字符 思路：判断字符串出现次数 代码123456789public boolean canConstruct(String ransomNote, String magazine) &#123; int[] vis = new int[26]; for(int i = 0;i &lt; magazine.length();i++) vis[magazine.charAt(i)-'a']++; for(int i = 0;i &lt; ransomNote.length();i++) if(--vis[ransomNote.charAt(i)-'a'] &lt; 0) return false; return true; &#125; 404. Sum of Left Leaves 题意：求一棵二叉树的所有左叶子的和 思路：递归左右子树，当一个点有左节点且左节点是叶子节点时返回该左节点的值 代码12345678910111213public int sumOfLeftLeaves(TreeNode root) &#123; if(root==null) return 0; int ans = 0; if(root.left!=null)&#123;//有左孩子 if(root.left.left == null &amp;&amp; root.left.right == null)//该节点是叶子节点 ans += root.left.val; else//递归下去 ans += sumOfLeftLeaves(root.left); &#125; ans+=sumOfLeftLeaves(root.right);//递归右孩子 return ans;&#125; 237. Delete Node in a Linked List 题意：删除链表指定的一个节点 思路：将该节点的val指向下一个，next指向下一个的下一个 代码1234public void deleteNode(ListNode node) &#123; node.val = node.next.val; node.next = node.next.next;&#125; 349. Intersection of Two Arrays 题意：计算两个数组的交集，所求集合中的元素唯一 思路：将第一个数组放入Set1，第二个数组放入Set2时，判断数组中的每个数字是否在Set1中，是的话就放入Set2 代码123456789101112131415public int[] intersection(int[] nums1, int[] nums2) &#123; Set&lt;Integer&gt; set1 = new HashSet&lt;Integer&gt;(); Set&lt;Integer&gt; set2 = new HashSet&lt;Integer&gt;(); for(int i = 0;i &lt;nums1.length;i++) set1.add(nums1[i]); for(int i = 0;i &lt; nums2.length;i++)&#123; if(set1.contains(nums2[i])) set2.add(nums2[i]); &#125; int[] ans = new int[set2.size()]; int i = 0; for(Integer num : set2) ans[i++] = num; return ans;&#125; 387. First Unique Character in a String 题意：从左到右找出一个字符串中第一个不重复的字符的下标，不存在返回-1 思路：遍历字符串，判断s.indexOf(str[i])==s.lastIndexOf(str[i]) 代码1234567public int firstUniqChar(String s) &#123; char[] str = s.toCharArray(); for(int i = 0; i &lt; str.length;i++) if(s.indexOf(str[i])==s.lastIndexOf(str[i])) return i; return -1;&#125; 171. Excel Sheet Column Number 题意：将excel sheet的列转出十进制，A-&gt;1,AA-&gt;27,AB-&gt;28 思路：就是将26进制转成十进制 代码123456public int titleToNumber(String s) &#123; int ans = 0; for(int i = 0;i &lt; s.length();i++) ans = ans*26 + (s.charAt(i)-'A'+1); return ans;&#125; 100. Same Tree 题意：判断两个二叉树是否一样（节点一致，节点值一致） 思路：递归判断左右子树 代码1234567public boolean isSameTree(TreeNode p, TreeNode q) &#123; if(p==null &amp;&amp; q==null) return true;//左或右结构一致，都为空 if(p==null || q==null) return false;//左右结构不一致，一个为空一个不为空 if(p.val==q.val) return isSameTree(p.left,q.left) &amp;&amp; isSameTree(p.right,q.right); return false; &#125; 242. Valid Anagram 题意：判断构成两个字符串的字符是否一样 思路：一个数组记录第一个字符串的字符出现的次数，遍历第二个字符串，将字符对应的数组的值-1，如果数组中的值有不为0的情况，则说明不一样 代码1234567public boolean isAnagram(String s, String t) &#123; int[] alphabet = new int[26]; for (int i = 0; i &lt; s.length(); i++) alphabet[s.charAt(i) - 'a']++; for (int i = 0; i &lt; t.length(); i++) alphabet[t.charAt(i) - 'a']--; for (int i : alphabet) if (i != 0) return false; return true;&#125; 169. Majority Element 题意：有一个数组，其中某个数字至少出现了n/2次，找出这个数字 思路：将数组排序，则这个数字一定出现在n/2+1的位置 代码1234public int majorityElement(int[] nums) &#123; Arrays.sort(nums); return nums[nums.length/2];&#125;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"LeetCode(Easy)-17/1/10","slug":"leetCode-17-1-10","date":"2017-01-10T08:13:02.000Z","updated":"2017-01-25T14:07:52.000Z","comments":true,"path":"2017/01/10/leetCode-17-1-10/","link":"","permalink":"http://yoursite.com/2017/01/10/leetCode-17-1-10/","excerpt":"","text":"461. Hamming Distance 题意：两个数字的二进制有多少位不同 思路：判断x^y的二进制结果有多少个1 1234567public int hammingDistance(int x, int y) &#123; int xor = x ^ y; int sum = 0; for(int i = 0;i&lt;=31;i++) sum +=(xor &gt;&gt; i) &amp; 1; return sum; &#125; 412. Fizz Buzz 题意：3的倍数输出Fizz，5的倍数输出Buzz，既是3的倍数也是5的倍数输出FizzBuzz 思路：先判断既是3和5的倍数的情况 代码 1234567891011121314public List&lt;String&gt; fizzBuzz(int n) &#123; List&lt;String&gt; ans = new ArrayList&lt;String&gt;(); for(Integer i = 1;i &lt;= n;i++)&#123; if(i%3==0 &amp;&amp; i%5==0) ans.add(\"FizzBuzz\"); else if(i%3==0) ans.add(\"Fizz\"); else if(i%5==0) ans.add(\"Buzz\"); else ans.add(i.toString()); &#125; return ans;&#125; 344. Reverse String 题意：反转一个字符串 思路：递归翻转，每次将字符串分半 代码12345public String reverseString(String s)&#123; if(s.length()&lt;=1) return s; return reverseString(s.substring(s.length()/2,s.length())) + reverseString(s.substring(0,s.length()/2));&#125; 463. Island Perimeter 题意：给一个01矩阵，1代表陆地，0代表海，问需要多少围栏将陆地围成一块 思路：遍历矩阵，假设一个1需要4个围栏，判断每个1四周是否为1，为1则减去一个围栏 代码12345678910111213141516171819202122232425public class Solution &#123; public int islandPerimeter(int[][] grid) &#123; int ans = 0; int x; int y; int[][] dir= new int[][]&#123;&#123;1,0&#125;,&#123;0,1&#125;,&#123;-1,0&#125;,&#123;0,-1&#125;&#125;; for(int i = 0;i&lt;grid.length;i++)&#123; for(int j =0;j&lt;grid[0].length;j++)&#123; if(grid[i][j]==1) &#123; int cnt = 4; for (int k = 0; k &lt; 4; k++) &#123; x = i + dir[k][0]; y = j + dir[k][1]; if (x &gt;= 0 &amp;&amp; x &lt; grid.length &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; grid[0].length) &#123; if (grid[x][y] == 1) cnt--; &#125; &#125; ans+=cnt; &#125; &#125; &#125; return ans; &#125;&#125; 448. Find All Numbers Disappeared in an Array 题意：找出数组（1≤a[i]≤n，n = size of array）中没出现的数字 思路： 开一个数组记录哪些数字出现过 对每个元素nums[nums[i] -1] = -nums[nums[i]-1]，最后哪个位置的值大于则该下标对应的数字就是没出现过的 代码12345678910111213public List&lt;Integer&gt; findDisappearedNumbers(int[] nums) &#123; List&lt;Integer&gt; ret = new ArrayList&lt;Integer&gt;(); for(int i = 0; i &lt; nums.length; i++) &#123; int val = Math.abs(nums[i]) - 1; if(nums[val] &gt; 0) nums[val] = -nums[val]; &#125; for(int i = 0; i &lt; nums.length; i++) &#123; if(nums[i] &gt; 0) ret.add(i+1); &#125; return ret; &#125; 136. Single Number 题意：给定一个整数数组，每个数字都出现两次但有个数字只出现一次，找出这个数字 思路：将数组所有的元素异或一遍，因为两个相同的数字异或的结果为0，0与一个数字异或结果不变 代码123456public int singleNumber(int[] nums) &#123; int ans = nums[0]; for(int i = 1;i &lt; nums.length;i++) ans^=nums[i]; return ans;&#125; 371. Sum of Two Integers 题意：不使用四则运算符实现两个数相加 思路：相同位相加时会进位 例子：7+2 =0111+0010 =0101+0100 =1000+0001 =1001（9） 代码12345678910public int getSum(int a, int b) &#123; if(a==0)return b; if(b==0)return a; while(b!=0)&#123; int carry = a &amp; b;//找相同位 a = a ^ b;//找不同位 b = carry&lt;&lt;1;//进位 &#125; return a; &#125; 104. Maximum Depth of Binary Tree 题意：求一棵二叉树的最大深度 思路：递归左右子树的深度，返回最大值 代码123456789101112131415161718/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public int maxDepth(TreeNode root) &#123; if(root == null) return 0; int depthLeft = maxDepth(root.left); int depthRight = maxDepth(root.right); return 1+(depthLeft &gt; depthRight ? depthLeft : depthRight); &#125;&#125; 389. Find the Difference 题意：给两个只包含小写的字符串，第二个字符串是在第一字符串随机洗乱后再随机插入一个字符，找出这个字符 思路： 两个数组记录每个字符串中小写字母出现的次数 通过异或运算 代码123456789public char findTheDifference(String s, String t) &#123; int n = t.length(); char c = t.charAt(n - 1); for (int i = 0; i &lt; n - 1; ++i) &#123; c ^= s.charAt(i); c ^= t.charAt(i); &#125; return c;&#125; 258. Add Digits 题意：给一个数反复的将每位数相加，直到结果为一位数（38-&gt;3+8=11-&gt;1+1=2） 思路： 递归求解 （100a+10b+c）%9 = (a+99a+b+9b+c)%9=(a+b+c)%9 代码123public int addDigits(int num) &#123; return num==0?0:(num%9==0?9:(num%9));&#125;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"CCPC2016长春赛后流水账","slug":"CCPC2016长春赛后流水账","date":"2016-10-03T05:56:09.000Z","updated":"2017-02-17T06:03:03.000Z","comments":true,"path":"2016/10/03/CCPC2016长春赛后流水账/","link":"","permalink":"http://yoursite.com/2016/10/03/CCPC2016长春赛后流水账/","excerpt":"","text":"8月14号各自在家中打网络赛，拿到一个长春赛区的名额。确认名额到参赛时间仅剩一个月时间。 day0七点半出发，在校门口和老板（教练）会和。由于特殊原因，从我们这一届开始，老板已经没有继续指导我们训练，所以一路上跟老板还是有些…尴尬吧。 先是轻轨，然后地铁，接着上了飞机（有个空姐真的巨漂亮），18点到达长春（长春当是还是蛮冷的=A=）,之后坐上了之前就预约好的接机，师傅一路上给我们介绍了长春的特产和景点，不过听他描述好像真没什么好吃好玩的..（司机开车有点生猛，一路狂飙，哇差点吐出来 之前还想着怎么开口跟老板说让他一个人住，我们三个人挤一间房，结果到了酒店老板自己说了- -|||，还约了八点下去吃火锅。吃火锅的时候老板给我们讲了一道概率题，说是已经在以往的比赛中碰到四五次了，其实当是听的一头雾水。（结果热身赛的时候真的碰到一摸一样的了:-)holyshit）然后谈到现在的协会，说我们神神秘秘自己搞，要是认真上完老板的acm1，2，省赛拿铜是轻易的事..（其实我也是前几天才知道为什么老板不再指导我们了，再想想省赛，去年13级1银3铜高校排名第八，今年的14级3铁滚粗…老板的重要性唉 回酒店的路上，老板说了，明天我们自己去，他去净月潭玩:-) day1去报道的路上遇到了同样参赛的选手，所以一路尾随，不用看地图了，看着人家的教练跟他们一路上有说有笑的，相比之下我们更像没有爸爸的孩子= =。报道的时候还遇见了隔壁北师珠的队员，由于并不熟悉，所以没有打招呼。 吉大真的大，找举办方指定的食堂找了超久。excuse me？那食堂在一栋类似购物广场的建筑里面，简直高大上 到赛场等热身赛，第一次参加这么大型的比赛还是超兴奋的找到位置的时候，发现右上方坐着清华的队伍（40分钟ak热身赛题目走人，rank1..再稍微吐槽一下，总感觉他们行为很怪异，可能特别聪明的人都这样吧拿到题目，第一题和老板昨晚说的题目基本可以说是一样的，结果我们三个人推不出来（概率题以前没怎么训练过..第二题，给定n，问符合规则的2*n的矩阵有多少个。由于是第一次组队，之前也没一起训练过，再加之是热身赛，所以比较随便，并没有过多的交流，各想各的，以至于最后每人写了一份代码，全部wa。结束后看了隔壁清华的代码，真的，我们玩的跟人家玩的根本不是同一种东西。第三题，朝钧上去尝试了一下爆搜，没写完，当时连题意都没搞清楚，全靠猜。 热身赛挂0结束 回到酒店，三人在酒店瘫了一晚上…（阴阳师真的有毒 day29点正式赛开始开始前在pc^2看到了题目标题，有两道序列I，序列II，所以我们猜序列I应该比较简单，所以一拿到题目我们先看了那道题。发现没什么思路，俊杰这时候已经在看B题了，写完，样例没过。我上去写了一发，把自己写晕了。朝钧尝试用递归来写，也晕了。（其实就是一道简单的模拟题 ..)这时已经有很多队伍两个气球了。俊杰还在整理思路，我和朝钧看D题，起初认为是贪心，跟俊杰说了思路，结果发现是斐波那契数列，马上写完交,RE，数组开小了。期间我看F题，起初没发现 k &lt; n/2 ，感觉挺棘手的，在发现后才发觉也是一道水题。108分钟2题，还是在铁牌区。俊杰继续调B题的代码，121分钟1A。接下来的时间就一直在死磕H了，在发现用kmp可以解决之后，敲了吉林大学kmp的模板，莫名其妙的wa了6发，最后用了神龙的模板A了（教训：不是自己的模板，真的信不过 剩下45分钟写J题，当是的思路是根据当前的字符串构建最接近他的回文串，又是大数，三个人java都不熟练，朝钧上去敲了c++的模板，敲完才发现模板是万进制的，无法一个个字符操作（如果当时自己模拟减法，可能就过，5题还能搭上铜牌的末班车..） 剩下10分钟，宣布GG,又打铁了。失落的回到酒店又瘫了一晚上 day3无聊的火车 day4无聊的火车 day5空手而归回到珠海 反思接触ACM两年了，今年是最后一年了，想想一路走来，自己真的不是很努力，一直打铁也不是没有原因 基础算法理解不深，一直都是拿着模板刷题库 欠缺高级算法 代码能力不强 数学知识面欠缺，很多大牛都能靠数据猜公式.. 队伍默契度不高 现场赛经验不足 世界很大 接下来的日子，好好上老板的课，写写CF,BC,看下年的省赛能不能拿块牌光荣退役吧！","categories":[],"tags":[{"name":"杂","slug":"杂","permalink":"http://yoursite.com/tags/杂/"}]},{"title":"[CodeVs1017]乘积最大","slug":"CodeVs1017-乘积最大","date":"2016-09-20T15:11:33.000Z","updated":"2017-02-24T01:18:44.000Z","comments":true,"path":"2016/09/20/CodeVs1017-乘积最大/","link":"","permalink":"http://yoursite.com/2016/09/20/CodeVs1017-乘积最大/","excerpt":"","text":"题目传送门 题意有一个长度为N的数字串，要求选手使用K个乘号将它分成K+1个部分，找出一种分法，使得这K+1个部分的乘积能够为最大。 分析水= =很容易推出转移方程dp[i][j] = max(dp[k][j - 1] * a[k][i - 1], dp[i][j]),1&lt;=k&lt;i;预处理一下k位到i-1位的数字 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;char arr[50];ll dp[50][50], a[50][50];int main()&#123; int N, K; scanf(\"%d%d\", &amp;N, &amp;K); scanf(\"%s\", arr); getchar(); for (int i = 0; i&lt;N; i++)&#123; a[i][i] = arr[i] - '0'; &#125; for (int i = 0; i&lt;N; i++)&#123; for (int j = i + 1; j&lt;N; j++)&#123; a[i][j] = a[i][j - 1] * 10 + arr[j] - '0'; &#125; &#125; for (int i = 1; i &lt;= N; i++)&#123; dp[i][0] = a[0][i - 1]; &#125; for (int i = 1; i &lt;= N; i++)&#123; for (int j = 1; j &lt;= i&amp;&amp;j &lt;= K; j++)&#123; for (int k = 1; k&lt;i; k++)&#123; if (k&gt;j - 1) dp[i][j] = max(dp[k][j - 1] * a[k][i - 1], dp[i][j]); &#125; &#125; &#125; printf(\"%lld\\n\", dp[N][K]); return 0;&#125;","categories":[],"tags":[{"name":"CodeVs","slug":"CodeVs","permalink":"http://yoursite.com/tags/CodeVs/"},{"name":"DP","slug":"DP","permalink":"http://yoursite.com/tags/DP/"}]},{"title":"[CodeVs1058]合唱队形","slug":"CodeVs1058-合唱队形","date":"2016-09-20T13:08:24.000Z","updated":"2017-02-17T07:13:35.000Z","comments":true,"path":"2016/09/20/CodeVs1058-合唱队形/","link":"","permalink":"http://yoursite.com/2016/09/20/CodeVs1058-合唱队形/","excerpt":"","text":"题目传送门 分析合唱队形即为左边是最大上升子序列，右边是最大下降子序列，则我们可以枚举中间节点i， up[i]表示以i结尾的最长上升子序列，down[i]表示以i开始的最长下降子序列，以免麻烦，我们从后往前求down[i]，则合唱队形人数为 max(up[i]+down[i]-1) 代码1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define MAXN 105using namespace std;int up[MAXN];int down[MAXN];int num[MAXN];int main() &#123; int n; int ans; while (cin &gt;&gt; n) &#123; ans = 0; for (int i = 1; i &lt;= n; i++)cin &gt;&gt; num[i],up[i]=1,down[i]=1; for (int i = 1; i &lt;= n; i++) &#123; for (int j = i-1; j &gt;=1; j--) &#123; if (num[i] &gt; num[j]) &#123; up[i] = max(up[j] + 1, up[i]); &#125; &#125; &#125; for (int i = n; i &gt;= 1; i--) &#123; for (int j = i+1; j &lt;=n; j++) &#123; if (num[i] &gt; num[j]) &#123; down[i] = max(down[j] + 1, down[i]); &#125; &#125; &#125; for (int i = 1; i &lt;= n; i++) ans = max(up[i] + down[i]-1, ans); cout &lt;&lt; n - ans &lt;&lt; endl; &#125; return 0;&#125;","categories":[],"tags":[{"name":"CodeVs","slug":"CodeVs","permalink":"http://yoursite.com/tags/CodeVs/"},{"name":"DP","slug":"DP","permalink":"http://yoursite.com/tags/DP/"}]},{"title":"[CodeVs3278]最小m 段和问题","slug":"CodeVs3278-最小m-段和问题","date":"2016-09-20T06:05:21.000Z","updated":"2017-02-17T06:10:10.000Z","comments":true,"path":"2016/09/20/CodeVs3278-最小m-段和问题/","link":"","permalink":"http://yoursite.com/2016/09/20/CodeVs3278-最小m-段和问题/","excerpt":"","text":"题目传送门 题意给定 n 个整数(不一定是正整数)组成的序列，现在要求将序列分割为 m 段，每段子序列中的数在原序列 中连续排列。如何分割才能使这 m 段子序列的和的最大值达到最小？ 分析dp[i][j]维护i结尾，分成j段的最大值 dp[i][j] = min(dp[i][j], max(dp[k][j - 1],dp[i][1]-dp[k][1])); 代码12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define MAXN 1005using namespace std;int dp[MAXN][MAXN];int sum[MAXN];int num;int main() &#123; int n, m; while (cin &gt;&gt; n &gt;&gt; m) &#123; if (n == 0 &amp;&amp; m == 0) &#123; cout &lt;&lt; \"0\" &lt;&lt; endl; continue; &#125; memset(sum, 0, sizeof(sum)); memset(dp, 0x7f, sizeof(dp)); dp[0][1] = 0; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; num; dp[i][1] = dp[i - 1][1] + num; &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 2; j &lt;= m; j++) &#123; for (int k = 1; k &lt; i; k++) &#123; dp[i][j] = min(dp[i][j], max(dp[k][j - 1],dp[i][1]-dp[k][1])); &#125; &#125; &#125; cout &lt;&lt; dp[n][m] &lt;&lt; endl; &#125; return 0;&#125;","categories":[],"tags":[{"name":"CodeVs","slug":"CodeVs","permalink":"http://yoursite.com/tags/CodeVs/"},{"name":"DP","slug":"DP","permalink":"http://yoursite.com/tags/DP/"}]},{"title":"[Codeforces701b]Cells Not Under Attack","slug":"Codeforces701b-Cells-Not-Under-Attack","date":"2016-07-28T14:12:50.000Z","updated":"2017-02-17T06:52:43.000Z","comments":true,"path":"2016/07/28/Codeforces701b-Cells-Not-Under-Attack/","link":"","permalink":"http://yoursite.com/2016/07/28/Codeforces701b-Cells-Not-Under-Attack/","excerpt":"","text":"题目传送门 题意给定一个n＊n的棋盘，如果一个点放了棋子那么该行该列都不能再放棋子了，现在给定一些棋子的位置，问还有多少格子可以放置棋子 分析两个数组分别记录每一行每一列还剩下多少空位置，暴力枚举每颗棋子对行和列的影响 代码123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;#include&lt;cstring&gt;#define MAXN 100005using namespace std;int x[MAXN];int y[MAXN];long long numx, numy;int n, m;int main()&#123; int a, b; while(cin&gt;&gt;n&gt;&gt;m)&#123; memset(x,0,sizeof(x)); memset(y,0,sizeof(y)); numx = numy = n; while(m--)&#123; cin&gt;&gt;a&gt;&gt;b; if(x[a]==0)&#123; x[a]++; numx--; &#125; if(y[b]==0)&#123; y[b]++; numy--; &#125; if(m!=0) cout&lt;&lt;numx*numy&lt;&lt;\" \"; else cout&lt;&lt;numx*numy&lt;&lt;endl; &#125; &#125;&#125;","categories":[],"tags":[{"name":"CodeForces","slug":"CodeForces","permalink":"http://yoursite.com/tags/CodeForces/"}]},{"title":"[Codeforces701C]They Are Everywhere","slug":"Codeforces701C-They-Are-Everywhere","date":"2016-07-28T07:03:17.000Z","updated":"2017-02-17T07:11:18.000Z","comments":true,"path":"2016/07/28/Codeforces701C-They-Are-Everywhere/","link":"","permalink":"http://yoursite.com/2016/07/28/Codeforces701C-They-Are-Everywhere/","excerpt":"","text":"Sergei B., the young coach of Pokemons, has found the big house which consists of n flats ordered in a row from left to right. It is possible to enter each flat from the street. It is possible to go out from each flat. Also, each flat is connected with the flat to the left and the flat to the right. Flat number 1 is only connected with the flat number 2 and the flat number n is only connected with the flat number n - 1. There is exactly one Pokemon of some type in each of these flats. Sergei B. asked residents of the house to let him enter their flats in order to catch Pokemons. After consulting the residents of the house decided to let Sergei B. enter one flat from the street, visit several flats and then go out from some flat. But they won’t let him visit the same flat more than once. Sergei B. was very pleased, and now he wants to visit as few flats as possible in order to collect Pokemons of all types that appear in this house. Your task is to help him and determine this minimum number of flats he has to visit. InputThe first line contains the integer n (1 ≤ n ≤ 100 000) — the number of flats in the house. The second line contains the row s with the length n, it consists of uppercase and lowercase letters of English alphabet, the i-th letter equals the type of Pokemon, which is in the flat number i. OutputPrint the minimum number of flats which Sergei B. should visit in order to catch Pokemons of all types which there are in the house. Examplesinput3AaA7bcAAcbc6aaBCCe output235 NoteIn the first test Sergei B. can begin, for example, from the flat number 1 and end in the flat number 2.In the second test Sergei B. can begin, for example, from the flat number 4 and end in the flat number 6.In the third test Sergei B. must begin from the flat number 2 and end in the flat number 6. 题意求最短的连续子串覆盖原串的所有元素 尺取法维护两个端点，根据实际情况交替推进两个端点直到得出答案，这种操作很像是尺蠖（日本中称为尺取虫）爬行的方式顾得名。1.初始两个端点2.推进右端点直到满足条件，跳至第三步3.推进左端点直到不满足条件，跳至第二步4.重复2，3步直至右端点走完整个区间 尺取法适合连续区间的问题，用尺取法来优化，使复杂度降为了O(n)。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;iostream&gt;#include&lt;cstring&gt;#define MAXN 100005using namespace std;char str[MAXN];int vis[200];int n;int num;int ans;int main()&#123; int l, r; int cnt; while(cin&gt;&gt;n)&#123; getchar(); ans = 0x3f3f3f3f; memset(vis,0,sizeof(vis)); num = 0; for(int i = 1;i &lt;= n;i++)&#123; scanf(\"%c\",&amp;str[i]); if(vis[str[i]]==0)&#123; vis[str[i]]++; num++; &#125; &#125; memset(vis,0,sizeof(vis)); cnt = 0; l = r = 1; while(1)&#123; if(r &gt; n) break; while(cnt &lt; num)&#123; if(r &gt; n) break; if(vis[str[r]] == 0)&#123; cnt++; &#125; vis[str[r]]++; r++; &#125; while(cnt &gt;= num)&#123; ans = ans &gt; (r-l) ? (r-l):ans; vis[str[l]]--; if(vis[str[l]]==0) cnt--; l++; &#125; &#125; printf(\"%d\\n\",ans); &#125; return 0;&#125;","categories":[],"tags":[{"name":"CodeForces","slug":"CodeForces","permalink":"http://yoursite.com/tags/CodeForces/"},{"name":"尺取法","slug":"尺取法","permalink":"http://yoursite.com/tags/尺取法/"}]},{"title":"[HDU5752]Sqrt Bo","slug":"HDU5752-Sqrt-Bo","date":"2016-07-26T13:55:40.000Z","updated":"2017-02-17T07:04:11.000Z","comments":true,"path":"2016/07/26/HDU5752-Sqrt-Bo/","link":"","permalink":"http://yoursite.com/2016/07/26/HDU5752-Sqrt-Bo/","excerpt":"","text":"Problem DescriptionLet’s define the function f(n)=⌊n√⌋. Bo wanted to know the minimum number y which satisfies fy(n)=1. note:f1(n)=f(n),fy(n)=f(fy−1(n)) It is a pity that Bo can only use 1 unit of time to calculate this function each time. And Bo is impatient, he cannot stand waiting for longer than 5 units of time. So Bo wants to know if he can solve this problem in 5 units of time. InputThis problem has multi test cases(no more than 120). Each test case contains a non-negative integer n(n&lt;10100). OutputFor each test case print a integer - the answer y or a string “TAT” - Bo can’t solve this problem. Sample Input233233333333333333333333333333333333333333333333333333333333 Sample Output3TAT Source2016 Multi-University Training Contest 3 分析由于有5次的这个限制，所以尝试寻找分界点。很容易发现是232，所以我们先比较输入的数字是否比这个大，然后再暴力开根。复杂度是O(loglogn)。注意特判n=0的情况。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;iostream&gt;using namespace std;char str[105];char m[]=\"4294967296\";long long num;int main()&#123; int t; int len; int flag; while(cin&gt;&gt;str)&#123; len = strlen(str); if(len&gt;10)&#123; printf(\"TAT\\n\"); continue; &#125; else if(len == 10)&#123; flag = 0; for(int i = 0;i&lt;len;i++)&#123; if(str[i]&gt;m[i])&#123; flag = 1; break; &#125; else if(str[i]&lt;m[i]) break; &#125; &#125; if(flag) printf(\"TAT\\n\"); else&#123; num = 0; for(int i = 0;i &lt; len;i++)&#123; num*=10; num+=str[i]-'0'; &#125; int ans = 0; while(num&gt;1)&#123; ans++; num = floor(sqrt(num*1.0)); &#125; if(ans&gt;5) printf(\"TAT\\n\"); else printf(\"%d\\n\",ans); &#125; &#125;&#125;","categories":[],"tags":[{"name":"HDU","slug":"HDU","permalink":"http://yoursite.com/tags/HDU/"}]},{"title":"[HDU5762]Teacher Bo","slug":"HDU5762-Teacher-Bo","date":"2016-07-26T06:53:09.000Z","updated":"2017-02-17T06:57:48.000Z","comments":true,"path":"2016/07/26/HDU5762-Teacher-Bo/","link":"","permalink":"http://yoursite.com/2016/07/26/HDU5762-Teacher-Bo/","excerpt":"","text":"Problem DescriptionTeacher BoBo is a geography teacher in the school.One day in his class,he marked N points in the map,the i-th point is at (Xi,Yi).He wonders,whether there is a tetrad (A,B,C,D)(A&lt;B,C&lt;D,A≠CorB≠D) such that the manhattan distance between A and B is equal to the manhattan distance between C and D. If there exists such tetrad,print “YES”,else print “NO”. InputFirst line, an integer T. There are T test cases.(T≤50) In each test case,the first line contains two intergers, N, M, means the number of points and the range of the coordinates.(N,M≤105). Next N lines, the i-th line shows the coordinate of the i-th point.(Xi,Yi)(0≤Xi,Yi≤M). OutputT lines, each line is “YES” or “NO”. Sample Input23 101 12 23 34 108 82 33 34 4 Sample OutputYESNO Source2016 Multi-University Training Contest 3 分析考虑一种暴力,每次枚举两两点对之间的曼哈顿距离,并开一个桶记录每种距离是否出现过,如果某次枚举出现了以前出现的距离就输 YES ,否则就输NO . 注意到曼哈顿距离只有O(M) 种,根据鸽笼原理,上面的算法在O(M) 步之内一定会停止.所以是可以过得. 一组数据的时间复杂度 O(min{N2,M}) . 代码123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#include&lt;cstring&gt;#define MAXN 100005using namespace std;int n, m;int vis[MAXN*10];int x[MAXN];int y[MAXN];bool solv()&#123; for(int i = 1;i &lt;= n;i++)&#123; for(int j = i+1;j &lt;= n;j++)&#123; int num = abs(x[i]-x[j])+abs(y[i]-y[j]); vis[num]++; if(vis[num]&gt;1) return true; &#125; &#125; return false;&#125;int main()&#123; int t; scanf(\"%d\",&amp;t); while(t--)&#123; memset(vis,0,sizeof(vis)); scanf(\"%d %d\",&amp;n,&amp;m); for(int i = 1;i &lt;= n;i++)&#123; scanf(\"%d %d\",&amp;x[i],&amp;y[i]); &#125; if(solv()) printf(\"YES\\n\"); else printf(\"NO\\n\"); &#125; return 0;&#125;","categories":[],"tags":[{"name":"HDU","slug":"HDU","permalink":"http://yoursite.com/tags/HDU/"}]}]}